This is guile-procedures.txt, produced by makeinfo version 4.0 from
guile-procedures.texi.

   acons

 - Scheme Procedure: acons key value alist
     Add a new key-value pair to ALIST.  A new pair is created whose
     car is KEY and whose cdr is VALUE, and the pair is consed onto
     ALIST, and the new list is returned.  This function is _not_
     destructive; ALIST is not modified.

   sloppy-assq

 - Scheme Procedure: sloppy-assq key alist
     Behaves like `assq' but does not do any error checking.
     Recommended only for use in Guile internals.

   sloppy-assv

 - Scheme Procedure: sloppy-assv key alist
     Behaves like `assv' but does not do any error checking.
     Recommended only for use in Guile internals.

   sloppy-assoc

 - Scheme Procedure: sloppy-assoc key alist
     Behaves like `assoc' but does not do any error checking.
     Recommended only for use in Guile internals.

   assq

 - Scheme Procedure: assq key alist
 - Scheme Procedure: assv key alist
 - Scheme Procedure: assoc key alist
     Fetch the entry in ALIST that is associated with KEY.  To decide
     whether the argument KEY matches a particular entry in ALIST,
     `assq' compares keys with `eq?', `assv' uses `eqv?' and `assoc'
     uses `equal?'.  If KEY cannot be found in ALIST (according to
     whichever equality predicate is in use), then return `#f'.  These
     functions return the entire alist entry found (i.e. both the key
     and the value).

   assv

 - Scheme Procedure: assv key alist
     Behaves like `assq' but uses `eqv?' for key comparison.

   assoc

 - Scheme Procedure: assoc key alist
     Behaves like `assq' but uses `equal?' for key comparison.

   assq-ref

 - Scheme Procedure: assq-ref alist key
 - Scheme Procedure: assv-ref alist key
 - Scheme Procedure: assoc-ref alist key
     Like `assq', `assv' and `assoc', except that only the value
     associated with KEY in ALIST is returned.  These functions are
     equivalent to

          (let ((ent (ASSOCIATOR KEY ALIST)))
            (and ent (cdr ent)))

     where ASSOCIATOR is one of `assq', `assv' or `assoc'.

   assv-ref

 - Scheme Procedure: assv-ref alist key
     Behaves like `assq-ref' but uses `eqv?' for key comparison.

   assoc-ref

 - Scheme Procedure: assoc-ref alist key
     Behaves like `assq-ref' but uses `equal?' for key comparison.

   assq-set!

 - Scheme Procedure: assq-set! alist key val
 - Scheme Procedure: assv-set! alist key value
 - Scheme Procedure: assoc-set! alist key value
     Reassociate KEY in ALIST with VALUE: find any existing ALIST entry
     for KEY and associate it with the new VALUE.  If ALIST does not
     contain an entry for KEY, add a new one.  Return the (possibly
     new) alist.

     These functions do not attempt to verify the structure of ALIST,
     and so may cause unusual results if passed an object that is not an
     association list.

   assv-set!

 - Scheme Procedure: assv-set! alist key val
     Behaves like `assq-set!' but uses `eqv?' for key comparison.

   assoc-set!

 - Scheme Procedure: assoc-set! alist key val
     Behaves like `assq-set!' but uses `equal?' for key comparison.

   assq-remove!

 - Scheme Procedure: assq-remove! alist key
 - Scheme Procedure: assv-remove! alist key
 - Scheme Procedure: assoc-remove! alist key
     Delete the first entry in ALIST associated with KEY, and return
     the resulting alist.

   assv-remove!

 - Scheme Procedure: assv-remove! alist key
     Behaves like `assq-remove!' but uses `eqv?' for key comparison.

   assoc-remove!

 - Scheme Procedure: assoc-remove! alist key
     Behaves like `assq-remove!' but uses `equal?' for key comparison.

   make-arbiter

 - Scheme Procedure: make-arbiter name
     Return an object of type arbiter and name NAME. Its state is
     initially unlocked.  Arbiters are a way to achieve process
     synchronization.

   try-arbiter

 - Scheme Procedure: try-arbiter arb
     Return `#t' and lock the arbiter ARB if the arbiter was unlocked.
     Otherwise, return `#f'.

   release-arbiter

 - Scheme Procedure: release-arbiter arb
     Return `#t' and unlock the arbiter ARB if the arbiter was locked.
     Otherwise, return `#f'.

   async

 - Scheme Procedure: async thunk
     Create a new async for the procedure THUNK.

   system-async

 - Scheme Procedure: system-async thunk
     Create a new async for the procedure THUNK.  Also add it to the
     system's list of active async objects.

   async-mark

 - Scheme Procedure: async-mark a
     Mark the async A for future execution.

   system-async-mark

 - Scheme Procedure: system-async-mark a
     Mark the async A for future execution.

   run-asyncs

 - Scheme Procedure: run-asyncs list_of_a
     Execute all thunks from the asyncs of the list LIST_OF_A.

   noop

 - Scheme Procedure: noop . args
     Do nothing.  When called without arguments, return `#f', otherwise
     return the first argument.

   unmask-signals

 - Scheme Procedure: unmask-signals
     Unmask signals. The returned value is not specified.

   mask-signals

 - Scheme Procedure: mask-signals
     Mask signals. The returned value is not specified.

   display-error

 - Scheme Procedure: display-error stack port subr message args rest
     Display an error message to the output port PORT.  STACK is the
     saved stack for the error, SUBR is the name of the procedure in
     which the error occurred and MESSAGE is the actual error message,
     which may contain formatting instructions. These will format the
     arguments in the list ARGS accordingly.  REST is currently ignored.

   display-application

 - Scheme Procedure: display-application frame [port [indent]]
     Display a procedure application FRAME to the output port PORT.
     INDENT specifies the indentation of the output.

   display-backtrace

 - Scheme Procedure: display-backtrace stack port [first [depth]]
     Display a backtrace to the output port PORT. STACK is the stack to
     take the backtrace from, FIRST specifies where in the stack to
     start and DEPTH how much frames to display. Both FIRST and DEPTH
     can be `#f', which means that default values will be used.

   backtrace

 - Scheme Procedure: backtrace
     Display a backtrace of the stack saved by the last error to the
     current output port.

   not

 - Scheme Procedure: not x
     Return `#t' iff X is `#f', else return `#f'.

   boolean?

 - Scheme Procedure: boolean? obj
     Return `#t' iff OBJ is either `#t' or `#f'.

   char?

 - Scheme Procedure: char? x
     Return `#t' iff X is a character, else `#f'.

   char=?

 - Scheme Procedure: char=? x y
     Return `#t' iff X is the same character as Y, else `#f'.

   char<?

 - Scheme Procedure: char<? x y
     Return `#t' iff X is less than Y in the ASCII sequence, else `#f'.

   char<=?

 - Scheme Procedure: char<=? x y
     Return `#t' iff X is less than or equal to Y in the ASCII
     sequence, else `#f'.

   char>?

 - Scheme Procedure: char>? x y
     Return `#t' iff X is greater than Y in the ASCII sequence, else
     `#f'.

   char>=?

 - Scheme Procedure: char>=? x y
     Return `#t' iff X is greater than or equal to Y in the ASCII
     sequence, else `#f'.

   char-ci=?

 - Scheme Procedure: char-ci=? x y
     Return `#t' iff X is the same character as Y ignoring case, else
     `#f'.

   char-ci<?

 - Scheme Procedure: char-ci<? x y
     Return `#t' iff X is less than Y in the ASCII sequence ignoring
     case, else `#f'.

   char-ci<=?

 - Scheme Procedure: char-ci<=? x y
     Return `#t' iff X is less than or equal to Y in the ASCII sequence
     ignoring case, else `#f'.

   char-ci>?

 - Scheme Procedure: char-ci>? x y
     Return `#t' iff X is greater than Y in the ASCII sequence ignoring
     case, else `#f'.

   char-ci>=?

 - Scheme Procedure: char-ci>=? x y
     Return `#t' iff X is greater than or equal to Y in the ASCII
     sequence ignoring case, else `#f'.

   char-alphabetic?

 - Scheme Procedure: char-alphabetic? chr
     Return `#t' iff CHR is alphabetic, else `#f'.  Alphabetic means
     the same thing as the isalpha C library function.

   char-numeric?

 - Scheme Procedure: char-numeric? chr
     Return `#t' iff CHR is numeric, else `#f'.  Numeric means the same
     thing as the isdigit C library function.

   char-whitespace?

 - Scheme Procedure: char-whitespace? chr
     Return `#t' iff CHR is whitespace, else `#f'.  Whitespace means
     the same thing as the isspace C library function.

   char-upper-case?

 - Scheme Procedure: char-upper-case? chr
     Return `#t' iff CHR is uppercase, else `#f'.  Uppercase means the
     same thing as the isupper C library function.

   char-lower-case?

 - Scheme Procedure: char-lower-case? chr
     Return `#t' iff CHR is lowercase, else `#f'.  Lowercase means the
     same thing as the islower C library function.

   char-is-both?

 - Scheme Procedure: char-is-both? chr
     Return `#t' iff CHR is either uppercase or lowercase, else `#f'.
     Uppercase and lowercase are as defined by the isupper and islower
     C library functions.

   char->integer

 - Scheme Procedure: char->integer chr
     Return the number corresponding to ordinal position of CHR in the
     ASCII sequence.

   integer->char

 - Scheme Procedure: integer->char n
     Return the character at position N in the ASCII sequence.

   char-upcase

 - Scheme Procedure: char-upcase chr
     Return the uppercase character version of CHR.

   char-downcase

 - Scheme Procedure: char-downcase chr
     Return the lowercase character version of CHR.

   debug-options-interface

 - Scheme Procedure: debug-options-interface [setting]
     Option interface for the debug options. Instead of using this
     procedure directly, use the procedures `debug-enable',
     `debug-disable', `debug-set!' and `debug-options'.

   with-traps

 - Scheme Procedure: with-traps thunk
     Call THUNK with traps enabled.

   memoized?

 - Scheme Procedure: memoized? obj
     Return `#t' if OBJ is memoized.

   unmemoize

 - Scheme Procedure: unmemoize m
     Unmemoize the memoized expression M,

   memoized-environment

 - Scheme Procedure: memoized-environment m
     Return the environment of the memoized expression M.

   procedure-name

 - Scheme Procedure: procedure-name proc
     Return the name of the procedure PROC

   procedure-source

 - Scheme Procedure: procedure-source proc
     Return the source of the procedure PROC.

   procedure-environment

 - Scheme Procedure: procedure-environment proc
     Return the environment of the procedure PROC.

   local-eval

 - Scheme Procedure: local-eval exp [env]
     Evaluate EXP in its environment.  If ENV is supplied, it is the
     environment in which to evaluate EXP.  Otherwise, EXP must be a
     memoized code object (in which case, its environment is implicit).

   debug-object?

 - Scheme Procedure: debug-object? obj
     Return `#t' if OBJ is a debug object.

   c-registered-modules

 - Scheme Procedure: c-registered-modules
     Return a list of the object code modules that have been imported
     into the current Guile process.  Each element of the list is a
     pair whose car is the name of the module, and whose cdr is the
     function handle for that module's initializer function.  The name
     is the string that has been passed to scm_register_module_xxx.

   c-clear-registered-modules

 - Scheme Procedure: c-clear-registered-modules
     Destroy the list of modules registered with the current Guile
     process.  The return value is unspecified.  *Warning:* this
     function does not actually unlink or deallocate these modules, but
     only destroys the records of which modules have been loaded.  It
     should therefore be used only by module bookkeeping operations.

   dynamic-link

 - Scheme Procedure: dynamic-link filename
     Open the dynamic library called FILENAME.  A library handle
     representing the opened library is returned; this handle should be
     used as the DOBJ argument to the following functions.

   dynamic-object?

 - Scheme Procedure: dynamic-object? obj
     Return `#t' if OBJ is a dynamic library handle, or `#f' otherwise.

   dynamic-unlink

 - Scheme Procedure: dynamic-unlink dobj
     Unlink the indicated object file from the application.  The
     argument DOBJ must have been obtained by a call to `dynamic-link'.
     After `dynamic-unlink' has been called on DOBJ, its content is no
     longer accessible.

   dynamic-func

 - Scheme Procedure: dynamic-func name dobj
     Search the dynamic object DOBJ for the C function indicated by the
     string NAME and return some Scheme handle that can later be used
     with `dynamic-call' to actually call the function.

     Regardless whether your C compiler prepends an underscore `_' to
     the global names in a program, you should *not* include this
     underscore in FUNCTION.  Guile knows whether the underscore is
     needed or not and will add it when necessary.

   dynamic-call

 - Scheme Procedure: dynamic-call func dobj
     Call the C function indicated by FUNC and DOBJ.  The function is
     passed no arguments and its return value is ignored.  When
     FUNCTION is something returned by `dynamic-func', call that
     function and ignore DOBJ.  When FUNC is a string , look it up in
     DYNOBJ; this is equivalent to
          (dynamic-call (dynamic-func FUNC DOBJ #f))

     Interrupts are deferred while the C function is executing (with
     `SCM_DEFER_INTS'/`SCM_ALLOW_INTS').

   dynamic-args-call

 - Scheme Procedure: dynamic-args-call func dobj args
     Call the C function indicated by FUNC and DOBJ, just like
     `dynamic-call', but pass it some arguments and return its return
     value.  The C function is expected to take two arguments and
     return an `int', just like `main':
          int c_func (int argc, char **argv);

     The parameter ARGS must be a list of strings and is converted into
     an array of `char *'.  The array is passed in ARGV and its size in
     ARGC.  The return value is converted to a Scheme number and
     returned from the call to `dynamic-args-call'.

   dynamic-wind

 - Scheme Procedure: dynamic-wind in_guard thunk out_guard
     All three arguments must be 0-argument procedures.  IN_GUARD is
     called, then THUNK, then OUT_GUARD.

     If, any time during the execution of THUNK, the continuation of
     the `dynamic_wind' expression is escaped non-locally, OUT_GUARD is
     called.  If the continuation of the dynamic-wind is re-entered,
     IN_GUARD is called.  Thus IN_GUARD and OUT_GUARD may be called any
     number of times.
          (define x 'normal-binding)
          => x
          (define a-cont  (call-with-current-continuation
          		  (lambda (escape)
          		     (let ((old-x x))
          		       (dynamic-wind
          			  ;; in-guard:
          			  ;;
          			  (lambda () (set! x 'special-binding))
          
          			  ;; thunk
          			  ;;
          		 	  (lambda () (display x) (newline)
          				     (call-with-current-continuation escape)
          				     (display x) (newline)
          				     x)
          
          			  ;; out-guard:
          			  ;;
          			  (lambda () (set! x old-x)))))))
          
          ;; Prints:
          special-binding
          ;; Evaluates to:
          => a-cont
          x
          => normal-binding
          (a-cont #f)
          ;; Prints:
          special-binding
          ;; Evaluates to:
          => a-cont  ;; the value of the (define a-cont...)
          x
          => normal-binding
          a-cont
          => special-binding

   environment?

 - Scheme Procedure: environment? obj
     Return `#t' if OBJ is an environment, or `#f' otherwise.

   environment-bound?

 - Scheme Procedure: environment-bound? env sym
     Return `#t' if SYM is bound in ENV, or `#f' otherwise.

   environment-ref

 - Scheme Procedure: environment-ref env sym
     Return the value of the location bound to SYM in ENV. If SYM is
     unbound in ENV, signal an `environment:unbound' error.

   environment-fold

 - Scheme Procedure: environment-fold env proc init
     Iterate over all the bindings in ENV, accumulating some value.
     For each binding in ENV, apply PROC to the symbol bound, its
     value, and the result from the previous application of PROC.  Use
     INIT as PROC's third argument the first time PROC is applied.  If
     ENV contains no bindings, this function simply returns INIT.  If
     ENV binds the symbol sym1 to the value val1, sym2 to val2, and so
     on, then this procedure computes:
            (proc sym1 val1
                  (proc sym2 val2
                        ...
                        (proc symn valn
                              init)))
     Each binding in ENV will be processed exactly once.
     `environment-fold' makes no guarantees about the order in which
     the bindings are processed.  Here is a function which, given an
     environment, constructs an association list representing that
     environment's bindings, using environment-fold:
            (define (environment->alist env)
              (environment-fold env
                                (lambda (sym val tail)
                                  (cons (cons sym val) tail))
                                '()))

   environment-define

 - Scheme Procedure: environment-define env sym val
     Bind SYM to a new location containing VAL in ENV. If SYM is
     already bound to another location in ENV and the binding is
     mutable, that binding is replaced.  The new binding and location
     are both mutable. The return value is unspecified.  If SYM is
     already bound in ENV, and the binding is immutable, signal an
     `environment:immutable-binding' error.

   environment-undefine

 - Scheme Procedure: environment-undefine env sym
     Remove any binding for SYM from ENV. If SYM is unbound in ENV, do
     nothing.  The return value is unspecified.  If SYM is already
     bound in ENV, and the binding is immutable, signal an
     `environment:immutable-binding' error.

   environment-set!

 - Scheme Procedure: environment-set! env sym val
     If ENV binds SYM to some location, change that location's value to
     VAL.  The return value is unspecified.  If SYM is not bound in
     ENV, signal an `environment:unbound' error.  If ENV binds SYM to
     an immutable location, signal an `environment:immutable-location'
     error.

   environment-cell

 - Scheme Procedure: environment-cell env sym for_write
     Return the value cell which ENV binds to SYM, or `#f' if the
     binding does not live in a value cell.  The argument FOR-WRITE
     indicates whether the caller intends to modify the variable's
     value by mutating the value cell.  If the variable is immutable,
     then `environment-cell' signals an
     `environment:immutable-location' error.  If SYM is unbound in ENV,
     signal an `environment:unbound' error.  If you use this function,
     you should consider using `environment-observe', to be notified
     when SYM gets re-bound to a new value cell, or becomes undefined.

   environment-observe

 - Scheme Procedure: environment-observe env proc
     Whenever ENV's bindings change, apply PROC to ENV.  This function
     returns an object, token, which you can pass to
     `environment-unobserve' to remove PROC from the set of procedures
     observing ENV.  The type and value of token is unspecified.

   environment-observe-weak

 - Scheme Procedure: environment-observe-weak env proc
     This function is the same as environment-observe, except that the
     reference ENV retains to PROC is a weak reference. This means
     that, if there are no other live, non-weak references to PROC, it
     will be garbage-collected, and dropped from ENV's list of
     observing procedures.

   environment-unobserve

 - Scheme Procedure: environment-unobserve token
     Cancel the observation request which returned the value TOKEN.
     The return value is unspecified.  If a call `(environment-observe
     env proc)' returns TOKEN, then the call `(environment-unobserve
     token)' will cause PROC to no longer be called when ENV's bindings
     change.

   make-leaf-environment

 - Scheme Procedure: make-leaf-environment
     Create a new leaf environment, containing no bindings.  All
     bindings and locations created in the new environment will be
     mutable.

   leaf-environment?

 - Scheme Procedure: leaf-environment? object
     Return `#t' if object is a leaf environment, or `#f' otherwise.

   make-eval-environment

 - Scheme Procedure: make-eval-environment local imported
     Return a new environment object eval whose bindings are the union
     of the bindings in the environments LOCAL and IMPORTED, with
     bindings from LOCAL taking precedence. Definitions made in eval
     are placed in LOCAL.  Applying `environment-define' or
     `environment-undefine' to eval has the same effect as applying the
     procedure to LOCAL.  Note that eval incorporates LOCAL and
     IMPORTED by reference: If, after creating eval, the program
     changes the bindings of LOCAL or IMPORTED, those changes will be
     visible in eval.  Since most Scheme evaluation takes place in eval
     environments, they transparently cache the bindings received from
     LOCAL and IMPORTED. Thus, the first time the program looks up a
     symbol in eval, eval may make calls to LOCAL or IMPORTED to find
     their bindings, but subsequent references to that symbol will be
     as fast as references to bindings in finite environments.  In
     typical use, LOCAL will be a finite environment, and IMPORTED will
     be an import environment

   eval-environment?

 - Scheme Procedure: eval-environment? object
     Return `#t' if object is an eval environment, or `#f' otherwise.

   eval-environment-local

 - Scheme Procedure: eval-environment-local env
     Return the local environment of eval environment ENV.

   eval-environment-set-local!

 - Scheme Procedure: eval-environment-set-local! env local
     Change ENV's local environment to LOCAL.

   eval-environment-imported

 - Scheme Procedure: eval-environment-imported env
     Return the imported environment of eval environment ENV.

   eval-environment-set-imported!

 - Scheme Procedure: eval-environment-set-imported! env imported
     Change ENV's imported environment to IMPORTED.

   make-import-environment

 - Scheme Procedure: make-import-environment imports conflict_proc
     Return a new environment IMP whose bindings are the union of the
     bindings from the environments in IMPORTS; IMPORTS must be a list
     of environments. That is, IMP binds a symbol to a location when
     some element of IMPORTS does.  If two different elements of
     IMPORTS have a binding for the same symbol, the CONFLICT-PROC is
     called with the following parameters:  the import environment, the
     symbol and the list of the imported environments that bind the
     symbol.  If the CONFLICT-PROC returns an environment ENV, the
     conflict is considered as resolved and the binding from ENV is
     used.  If the CONFLICT-PROC returns some non-environment object,
     the conflict is considered unresolved and the symbol is treated as
     unspecified in the import environment.  The checking for conflicts
     may be performed lazily, i. e. at the moment when a value or
     binding for a certain symbol is requested instead of the moment
     when the environment is created or the bindings of the imports
     change.  All bindings in IMP are immutable. If you apply
     `environment-define' or `environment-undefine' to IMP, Guile will
     signal an  `environment:immutable-binding' error. However, notice
     that the set of bindings in IMP may still change, if one of its
     imported environments changes.

   import-environment?

 - Scheme Procedure: import-environment? object
     Return `#t' if object is an import environment, or `#f' otherwise.

   import-environment-imports

 - Scheme Procedure: import-environment-imports env
     Return the list of environments imported by the import environment
     ENV.

   import-environment-set-imports!

 - Scheme Procedure: import-environment-set-imports! env imports
     Change ENV's list of imported environments to IMPORTS, and check
     for conflicts.

   make-export-environment

 - Scheme Procedure: make-export-environment private signature
     Return a new environment EXP containing only those bindings in
     private whose symbols are present in SIGNATURE. The PRIVATE
     argument must be an environment.

     The environment EXP binds symbol to location when ENV does, and
     symbol is exported by SIGNATURE.

     SIGNATURE is a list specifying which of the bindings in PRIVATE
     should be visible in EXP. Each element of SIGNATURE should be a
     list of the form:   (symbol attribute ...)  where each attribute
     is one of the following:
    the symbol `mutable-location'
          EXP should treat the   location bound to symbol as mutable.
          That is, EXP   will pass calls to `environment-set!' or
          `environment-cell' directly through to private.

    the symbol `immutable-location'
          EXP should treat   the location bound to symbol as immutable.
          If the program   applies `environment-set!' to EXP and
          symbol, or   calls `environment-cell' to obtain a writable
          value   cell, `environment-set!' will signal an
          `environment:immutable-location' error. Note that, even   if
          an export environment treats a location as immutable, the
          underlying environment may treat it as mutable, so its
          value may change.  It is an error for an element of signature
     to specify both `mutable-location' and `immutable-location'. If
     neither is specified, `immutable-location' is assumed.

     As a special case, if an element of signature is a lone symbol
     SYM, it is equivalent to an element of the form `(sym)'.

     All bindings in EXP are immutable. If you apply
     `environment-define' or `environment-undefine' to EXP, Guile will
     signal an `environment:immutable-binding' error. However, notice
     that the set of bindings in EXP may still change, if the bindings
     in private change.

   export-environment?

 - Scheme Procedure: export-environment? object
     Return `#t' if object is an export environment, or `#f' otherwise.

   export-environment-private

 - Scheme Procedure: export-environment-private env
     Return the private environment of export environment ENV.

   export-environment-set-private!

 - Scheme Procedure: export-environment-set-private! env private
     Change the private environment of export environment ENV.

   export-environment-signature

 - Scheme Procedure: export-environment-signature env
     Return the signature of export environment ENV.

   export-environment-set-signature!

 - Scheme Procedure: export-environment-set-signature! env signature
     Change the signature of export environment ENV.

   eq?

 - Scheme Procedure: eq? x y
     Return `#t' iff X references the same object as Y.  `eq?' is
     similar to `eqv?' except that in some cases it is capable of
     discerning distinctions finer than those detectable by `eqv?'.

   eqv?

 - Scheme Procedure: eqv? x y
     The `eqv?' procedure defines a useful equivalence relation on
     objects.  Briefly, it returns `#t' if X and Y should normally be
     regarded as the same object.  This relation is left slightly open
     to interpretation, but works for comparing immediate integers,
     characters, and inexact numbers.

   equal?

 - Scheme Procedure: equal? x y
     Return `#t' iff X and Y are recursively `eqv?' equivalent.
     `equal?' recursively compares the contents of pairs, vectors, and
     strings, applying `eqv?' on other objects such as numbers and
     symbols.  A rule of thumb is that objects are generally `equal?'
     if they print the same.  `equal?' may fail to terminate if its
     arguments are circular data structures.

   scm-error

 - Scheme Procedure: scm-error key subr message args data
     Raise an error with key KEY.  SUBR can be a string naming the
     procedure associated with the error, or `#f'.  MESSAGE is the
     error message string, possibly containing `~S' and `~A' escapes.
     When an error is reported, these are replaced by formatting the
     corresponding members of ARGS: `~A' (was `%s' in older versions of
     Guile) formats using `display' and `~S' (was `%S') formats using
     `write'.  DATA is a list or `#f' depending on KEY: if KEY is
     `system-error' then it should be a list containing the Unix
     `errno' value; If KEY is `signal' then it should be a list
     containing the Unix signal number; otherwise it will usually be
     `#f'.

   strerror

 - Scheme Procedure: strerror err
     Return the Unix error message corresponding to ERR, which must be
     an integer value.

   apply:nconc2last

 - Scheme Procedure: apply:nconc2last lst
     Given a list (ARG1 ... ARGS), this function conses the ARG1 ...
     arguments onto the front of ARGS, and returns the resulting list.
     Note that ARGS is a list; thus, the argument to this function is a
     list whose last element is a list.  Note: Rather than do new
     consing, `apply:nconc2last' destroys its argument, so use with
     care.

   force

 - Scheme Procedure: force x
     If the promise X has not been computed yet, compute and return X,
     otherwise just return the previously computed value.

   promise?

 - Scheme Procedure: promise? obj
     Return true if OBJ is a promise, i.e. a delayed computation (*note
     Delayed evaluation: (r5rs.info)Delayed evaluation.).

   cons-source

 - Scheme Procedure: cons-source xorig x y
     Create and return a new pair whose car and cdr are X and Y.  Any
     source properties associated with XORIG are also associated with
     the new pair.

   copy-tree

 - Scheme Procedure: copy-tree obj
     Recursively copy the data tree that is bound to OBJ, and return a
     pointer to the new data structure.  `copy-tree' recurses down the
     contents of both pairs and vectors (since both cons cells and
     vector cells may point to arbitrary objects), and stops recursing
     when it hits any other object.

   primitive-eval

 - Scheme Procedure: primitive-eval exp
     Evaluate EXP in the top-level environment specified by the current
     module.

   eval

 - Scheme Procedure: eval exp module
     Evaluate EXP, a list representing a Scheme expression, in the
     top-level environment specified by MODULE.  While EXP is evaluated
     (using `primitive-eval'), MODULE is made the current module.  The
     current module is reset to its previous value when EVAL returns.

   eval2

 - Scheme Procedure: eval2 obj env_thunk
     Evaluate EXP, a Scheme expression, in the environment designated
     by LOOKUP, a symbol-lookup function.  Do not use this version of
     eval, it does not play well with the module system.  Use `eval' or
     `primitive-eval' instead.

   eval-options-interface

 - Scheme Procedure: eval-options-interface [setting]
     Option interface for the evaluation options. Instead of using this
     procedure directly, use the procedures `eval-enable',
     `eval-disable', `eval-set!' and `eval-options'.

   evaluator-traps-interface

 - Scheme Procedure: evaluator-traps-interface [setting]
     Option interface for the evaluator trap options.

   defined?

 - Scheme Procedure: defined? sym [env]
     Return `#t' if SYM is defined in the lexical environment ENV.
     When ENV is not specified, look in the top-level environment as
     defined by the current module.

   map-in-order

 - Scheme Procedure: map-in-order
     implemented by the C function "scm_map"

   load-extension

 - Scheme Procedure: load-extension lib init
     Load and initialize the extension designated by LIB and INIT.
     When there is no pre-registered function for LIB/INIT, this is
     equivalent to

          (dynamic-call INIT (dynamic-link LIB))

     When there is a pre-registered function, that function is called
     instead.

     Normally, there is no pre-registered function.  This option exists
     only for situations where dynamic linking is unavailable or
     unwanted.  In that case, you would statically link your program
     with the desired library, and register its init function right
     after Guile has been initialized.

     LIB should be a string denoting a shared library without any file
     type suffix such as ".so".  The suffix is provided automatically.
     It should also not contain any directory components.  Libraries
     that implement Guile Extensions should be put into the normal
     locations for shared libraries.  We recommend to use the naming
     convention libguile-bla-blum for a extension related to a module
     `(bla blum)'.

     The normal way for a extension to be used is to write a small
     Scheme file that defines a module, and to load the extension into
     this module.  When the module is auto-loaded, the extension is
     loaded as well.  For example,

          (define-module (bla blum))
          
          (load-extension "libguile-bla-blum" "bla_init_blum")

   program-arguments

 - Scheme Procedure: program-arguments
 - Scheme Procedure: command-line
     Return the list of command line arguments passed to Guile, as a
     list of strings.  The list includes the invoked program name,
     which is usually `"guile"', but excludes switches and parameters
     for command line options like `-e' and `-l'.

   make-fluid

 - Scheme Procedure: make-fluid
     Return a newly created fluid.  Fluids are objects of a certain
     type (a smob) that can hold one SCM value per dynamic root.  That
     is, modifications to this value are only visible to code that
     executes within the same dynamic root as the modifying code.  When
     a new dynamic root is constructed, it inherits the values from its
     parent.  Because each thread executes in its own dynamic root, you
     can use fluids for thread local storage.

   fluid?

 - Scheme Procedure: fluid? obj
     Return `#t' iff OBJ is a fluid; otherwise, return `#f'.

   fluid-ref

 - Scheme Procedure: fluid-ref fluid
     Return the value associated with FLUID in the current dynamic
     root.  If FLUID has not been set, then return `#f'.

   fluid-set!

 - Scheme Procedure: fluid-set! fluid value
     Set the value associated with FLUID in the current dynamic root.

   with-fluids*

 - Scheme Procedure: with-fluids* fluids values thunk
     Set FLUIDS to VALUES temporary, and call THUNK.  FLUIDS must be a
     list of fluids and VALUES must be the same number of their values
     to be applied.  Each substitution is done one after another.
     THUNK must be a procedure with no argument.

   setvbuf

 - Scheme Procedure: setvbuf port mode [size]
     Set the buffering mode for PORT.  MODE can be:
    `_IONBF'
          non-buffered

    `_IOLBF'
          line buffered

    `_IOFBF'
          block buffered, using a newly allocated buffer of SIZE bytes.
          If SIZE is omitted, a default size will be used.

   file-port?

 - Scheme Procedure: file-port? obj
     Determine whether OBJ is a port that is related to a file.

   open-file

 - Scheme Procedure: open-file filename mode
     Open the file whose name is FILENAME, and return a port
     representing that file.  The attributes of the port are determined
     by the MODE string.  The way in which this is interpreted is
     similar to C stdio.  The first character must be one of the
     following:
    `r'
          Open an existing file for input.

    `w'
          Open a file for output, creating it if it doesn't already
          exist or removing its contents if it does.

    `a'
          Open a file for output, creating it if it doesn't already
          exist.  All writes to the port will go to the end of the file.
          The "append mode" can be turned off while the port is in use
          *note fcntl: Ports and File Descriptors.  The following
     additional characters can be appended:
    `+'
          Open the port for both input and output.  E.g., `r+': open an
          existing file for both input and output.

    `0'
          Create an "unbuffered" port.  In this case input and output
          operations are passed directly to the underlying port
          implementation without additional buffering.  This is likely
          to slow down I/O operations.  The buffering mode can be
          changed while a port is in use *note setvbuf: Ports and File
          Descriptors.

    `l'
          Add line-buffering to the port.  The port output buffer will
          be automatically flushed whenever a newline character is
          written.  In theory we could create read/write ports which
     were buffered in one direction only.  However this isn't included
     in the current interfaces.  If a file cannot be opened with the
     access requested, `open-file' throws an exception.

   gc-stats

 - Scheme Procedure: gc-stats
     Return an association list of statistics about Guile's current use
     of storage.

   object-address

 - Scheme Procedure: object-address obj
     Return an integer that for the lifetime of OBJ is uniquely
     returned by this function for OBJ

   gc

 - Scheme Procedure: gc
     Scans all of SCM objects and reclaims for further use those that
     are no longer accessible.

   %compute-slots

 - Scheme Procedure: %compute-slots class
     Return a list consisting of the names of all slots belonging to
     class CLASS, i. e. the slots of CLASS and of all of its
     superclasses.

   get-keyword

 - Scheme Procedure: get-keyword key l default_value
     Determine an associated value for the keyword KEY from the list L.
     The list L has to consist of an even number of elements, where,
     starting with the first, every second element is a keyword,
     followed by its associated value.  If L does not hold a value for
     KEY, the value DEFAULT_VALUE is returned.

   %initialize-object

 - Scheme Procedure: %initialize-object obj initargs
     Initialize the object OBJ with the given arguments INITARGS.

   %prep-layout!

 - Scheme Procedure: %prep-layout! class

   %inherit-magic!

 - Scheme Procedure: %inherit-magic! class dsupers

   instance?

 - Scheme Procedure: instance? obj
     Return `#t' if OBJ is an instance.

   class-name

 - Scheme Procedure: class-name obj
     Return the class name of OBJ.

   class-direct-supers

 - Scheme Procedure: class-direct-supers obj
     Return the direct superclasses of the class OBJ.

   class-direct-slots

 - Scheme Procedure: class-direct-slots obj
     Return the direct slots of the class OBJ.

   class-direct-subclasses

 - Scheme Procedure: class-direct-subclasses obj
     Return the direct subclasses of the class OBJ.

   class-direct-methods

 - Scheme Procedure: class-direct-methods obj
     Return the direct methods of the class OBJ

   class-precedence-list

 - Scheme Procedure: class-precedence-list obj
     Return the class precedence list of the class OBJ.

   class-slots

 - Scheme Procedure: class-slots obj
     Return the slot list of the class OBJ.

   class-environment

 - Scheme Procedure: class-environment obj
     Return the environment of the class OBJ.

   generic-function-name

 - Scheme Procedure: generic-function-name obj
     Return the name of the generic function OBJ.

   generic-function-methods

 - Scheme Procedure: generic-function-methods obj
     Return the methods of the generic function OBJ.

   method-generic-function

 - Scheme Procedure: method-generic-function obj
     Return the generic function for the method OBJ.

   method-specializers

 - Scheme Procedure: method-specializers obj
     Return specializers of the method OBJ.

   method-procedure

 - Scheme Procedure: method-procedure obj
     Return the procedure of the method OBJ.

   accessor-method-slot-definition

 - Scheme Procedure: accessor-method-slot-definition obj
     Return the slot definition of the accessor OBJ.

   %tag-body

 - Scheme Procedure: %tag-body body
     Internal GOOPS magic--don't use this function!

   make-unbound

 - Scheme Procedure: make-unbound
     Return the unbound value.

   unbound?

 - Scheme Procedure: unbound? obj
     Return `#t' if OBJ is unbound.

   assert-bound

 - Scheme Procedure: assert-bound value obj
     Return VALUE if it is bound, and invoke the SLOT-UNBOUND method of
     OBJ if it is not.

   @assert-bound-ref

 - Scheme Procedure: @assert-bound-ref obj index
     Like `assert-bound', but use INDEX for accessing the value from
     OBJ.

   %fast-slot-ref

 - Scheme Procedure: %fast-slot-ref obj index
     Return the slot value with index INDEX from OBJ.

   %fast-slot-set!

 - Scheme Procedure: %fast-slot-set! obj index value
     Set the slot with index INDEX in OBJ to VALUE.

   slot-ref-using-class

 - Scheme Procedure: slot-ref-using-class class obj slot_name

   slot-set-using-class!

 - Scheme Procedure: slot-set-using-class! class obj slot_name value

   slot-bound-using-class?

 - Scheme Procedure: slot-bound-using-class? class obj slot_name

   slot-exists-using-class?

 - Scheme Procedure: slot-exists-using-class? class obj slot_name

   slot-ref

 - Scheme Procedure: slot-ref obj slot_name
     Return the value from OBJ's slot with the name SLOT_NAME.

   slot-set!

 - Scheme Procedure: slot-set! obj slot_name value
     Set the slot named SLOT_NAME of OBJ to VALUE.

   slot-bound?

 - Scheme Procedure: slot-bound? obj slot_name
     Return `#t' if the slot named SLOT_NAME of OBJ is bound.

   slot-exists?

 - Scheme Procedure: slot-exists? obj slot_name
     Return `#t' if OBJ has a slot named SLOT_NAME.

   %allocate-instance

 - Scheme Procedure: %allocate-instance class initargs
     Create a new instance of class CLASS and initialize it from the
     arguments INITARGS.

   %set-object-setter!

 - Scheme Procedure: %set-object-setter! obj setter

   %modify-instance

 - Scheme Procedure: %modify-instance old new

   %modify-class

 - Scheme Procedure: %modify-class old new

   %invalidate-class

 - Scheme Procedure: %invalidate-class class

   %invalidate-method-cache!

 - Scheme Procedure: %invalidate-method-cache! gf

   generic-capability?

 - Scheme Procedure: generic-capability? proc

   enable-primitive-generic!

 - Scheme Procedure: enable-primitive-generic! . subrs

   primitive-generic-generic

 - Scheme Procedure: primitive-generic-generic subr

   make

 - Scheme Procedure: make . args
     Make a new object.  ARGS must contain the class and all necessary
     initialization information.

   find-method

 - Scheme Procedure: find-method . l

   %method-more-specific?

 - Scheme Procedure: %method-more-specific? m1 m2 targs

   %goops-loaded

 - Scheme Procedure: %goops-loaded
     Announce that GOOPS is loaded and perform initialization on the C
     level which depends on the loaded GOOPS modules.

   make-guardian

 - Scheme Procedure: make-guardian [greedy_p]
     Create a new guardian.  A guardian protects a set of objects from
     garbage collection, allowing a program to apply cleanup or other
     actions.

     `make-guardian' returns a procedure representing the guardian.
     Calling the guardian procedure with an argument adds the argument
     to the guardian's set of protected objects.  Calling the guardian
     procedure without an argument returns one of the protected objects
     which are ready for garbage collection, or `#f' if no such object
     is available.  Objects which are returned in this way are removed
     from the guardian.

     `make-guardian' takes one optional argument that says whether the
     new guardian should be greedy or sharing.  If there is any chance
     that any object protected by the guardian may be resurrected, then
     you should make the guardian greedy (this is the default).

     See R. Kent Dybvig, Carl Bruggeman, and David Eby (1993)
     "Guardians in a Generation-Based Garbage Collector".  ACM SIGPLAN
     Conference on Programming Language Design and Implementation, June
     1993.

     (the semantics are slightly different at this point, but the paper
     still (mostly) accurately describes the interface).

   guardian-destroyed?

 - Scheme Procedure: guardian-destroyed? guardian
     Return `#t' if GUARDIAN has been destroyed, otherwise `#f'.

   guardian-greedy?

 - Scheme Procedure: guardian-greedy? guardian
     Return `#t' if GUARDIAN is a greedy guardian, otherwise `#f'.

   destroy-guardian!

 - Scheme Procedure: destroy-guardian! guardian
     Destroys GUARDIAN, by making it impossible to put any more objects
     in it or get any objects from it.  It also unguards any objects
     guarded by GUARDIAN.

   hashq

 - Scheme Procedure: hashq key size
     Determine a hash value for KEY that is suitable for lookups in a
     hashtable of size SIZE, where `eq?' is used as the equality
     predicate.  The function returns an integer in the range 0 to SIZE
     - 1.  Note that `hashq' may use internal addresses.  Thus two
     calls to hashq where the keys are `eq?' are not guaranteed to
     deliver the same value if the key object gets garbage collected in
     between.  This can happen, for example with symbols: `(hashq 'foo
     n) (gc) (hashq 'foo n)' may produce two different values, since
     `foo' will be garbage collected.

   hashv

 - Scheme Procedure: hashv key size
     Determine a hash value for KEY that is suitable for lookups in a
     hashtable of size SIZE, where `eqv?' is used as the equality
     predicate.  The function returns an integer in the range 0 to SIZE
     - 1.  Note that `(hashv key)' may use internal addresses.  Thus
     two calls to hashv where the keys are `eqv?' are not guaranteed to
     deliver the same value if the key object gets garbage collected in
     between.  This can happen, for example with symbols: `(hashv 'foo
     n) (gc) (hashv 'foo n)' may produce two different values, since
     `foo' will be garbage collected.

   hash

 - Scheme Procedure: hash key size
     Determine a hash value for KEY that is suitable for lookups in a
     hashtable of size SIZE, where `equal?' is used as the equality
     predicate.  The function returns an integer in the range 0 to SIZE
     - 1.

   hashq-get-handle

 - Scheme Procedure: hashq-get-handle table key
     This procedure returns the `(key . value)' pair from the hash
     table TABLE.  If TABLE does not hold an associated value for KEY,
     `#f' is returned.  Uses `eq?' for equality testing.

   hashq-create-handle!

 - Scheme Procedure: hashq-create-handle! table key init
     This function looks up KEY in TABLE and returns its handle.  If
     KEY is not already present, a new handle is created which
     associates KEY with INIT.

   hashq-ref

 - Scheme Procedure: hashq-ref table key [dflt]
     Look up KEY in the hash table TABLE, and return the value (if any)
     associated with it.  If KEY is not found, return DEFAULT (or `#f'
     if no DEFAULT argument is supplied).  Uses `eq?' for equality
     testing.

   hashq-set!

 - Scheme Procedure: hashq-set! table key val
     Find the entry in TABLE associated with KEY, and store VALUE
     there. Uses `eq?' for equality testing.

   hashq-remove!

 - Scheme Procedure: hashq-remove! table key
     Remove KEY (and any value associated with it) from TABLE.  Uses
     `eq?' for equality tests.

   hashv-get-handle

 - Scheme Procedure: hashv-get-handle table key
     This procedure returns the `(key . value)' pair from the hash
     table TABLE.  If TABLE does not hold an associated value for KEY,
     `#f' is returned.  Uses `eqv?' for equality testing.

   hashv-create-handle!

 - Scheme Procedure: hashv-create-handle! table key init
     This function looks up KEY in TABLE and returns its handle.  If
     KEY is not already present, a new handle is created which
     associates KEY with INIT.

   hashv-ref

 - Scheme Procedure: hashv-ref table key [dflt]
     Look up KEY in the hash table TABLE, and return the value (if any)
     associated with it.  If KEY is not found, return DEFAULT (or `#f'
     if no DEFAULT argument is supplied).  Uses `eqv?' for equality
     testing.

   hashv-set!

 - Scheme Procedure: hashv-set! table key val
     Find the entry in TABLE associated with KEY, and store VALUE
     there. Uses `eqv?' for equality testing.

   hashv-remove!

 - Scheme Procedure: hashv-remove! table key
     Remove KEY (and any value associated with it) from TABLE.  Uses
     `eqv?' for equality tests.

   hash-get-handle

 - Scheme Procedure: hash-get-handle table key
     This procedure returns the `(key . value)' pair from the hash
     table TABLE.  If TABLE does not hold an associated value for KEY,
     `#f' is returned.  Uses `equal?' for equality testing.

   hash-create-handle!

 - Scheme Procedure: hash-create-handle! table key init
     This function looks up KEY in TABLE and returns its handle.  If
     KEY is not already present, a new handle is created which
     associates KEY with INIT.

   hash-ref

 - Scheme Procedure: hash-ref table key [dflt]
     Look up KEY in the hash table TABLE, and return the value (if any)
     associated with it.  If KEY is not found, return DEFAULT (or `#f'
     if no DEFAULT argument is supplied).  Uses `equal?' for equality
     testing.

   hash-set!

 - Scheme Procedure: hash-set! table key val
     Find the entry in TABLE associated with KEY, and store VALUE
     there. Uses `equal?' for equality testing.

   hash-remove!

 - Scheme Procedure: hash-remove! table key
     Remove KEY (and any value associated with it) from TABLE.  Uses
     `equal?' for equality tests.

   hashx-get-handle

 - Scheme Procedure: hashx-get-handle hash assoc table key
     This behaves the same way as the corresponding `-get-handle'
     function, but uses HASH as a hash function and ASSOC to compare
     keys.  `hash' must be a function that takes two arguments, a key
     to be hashed and a table size.  `assoc' must be an associator
     function, like `assoc', `assq' or `assv'.

   hashx-create-handle!

 - Scheme Procedure: hashx-create-handle! hash assoc table key init
     This behaves the same way as the corresponding `-create-handle'
     function, but uses HASH as a hash function and ASSOC to compare
     keys.  `hash' must be a function that takes two arguments, a key
     to be hashed and a table size.  `assoc' must be an associator
     function, like `assoc', `assq' or `assv'.

   hashx-ref

 - Scheme Procedure: hashx-ref hash assoc table key [dflt]
     This behaves the same way as the corresponding `ref' function, but
     uses HASH as a hash function and ASSOC to compare keys.  `hash'
     must be a function that takes two arguments, a key to be hashed
     and a table size.  `assoc' must be an associator function, like
     `assoc', `assq' or `assv'.

     By way of illustration, `hashq-ref table key' is equivalent to
     `hashx-ref hashq assq table key'.

   hashx-set!

 - Scheme Procedure: hashx-set! hash assoc table key val
     This behaves the same way as the corresponding `set!' function,
     but uses HASH as a hash function and ASSOC to compare keys.
     `hash' must be a function that takes two arguments, a key to be
     hashed and a table size.  `assoc' must be an associator function,
     like `assoc', `assq' or `assv'.

     By way of illustration, `hashq-set! table key' is equivalent to
     `hashx-set!  hashq assq table key'.

   hash-fold

 - Scheme Procedure: hash-fold proc init table
     An iterator over hash-table elements.  Accumulates and returns a
     result by applying PROC successively.  The arguments to PROC are
     "(key value prior-result)" where key and value are successive
     pairs from the hash table TABLE, and prior-result is either INIT
     (for the first application of PROC) or the return value of the
     previous application of PROC.  For example, `(hash-fold acons '()
     tab)' will convert a hash table into an a-list of key-value pairs.

   make-hook

 - Scheme Procedure: make-hook [n_args]
     Create a hook for storing procedure of arity N_ARGS.  N_ARGS
     defaults to zero.  The returned value is a hook object to be used
     with the other hook procedures.

   hook?

 - Scheme Procedure: hook? x
     Return `#t' if X is a hook, `#f' otherwise.

   hook-empty?

 - Scheme Procedure: hook-empty? hook
     Return `#t' if HOOK is an empty hook, `#f' otherwise.

   add-hook!

 - Scheme Procedure: add-hook! hook proc [append_p]
     Add the procedure PROC to the hook HOOK. The procedure is added to
     the end if APPEND_P is true, otherwise it is added to the front.
     The return value of this procedure is not specified.

   remove-hook!

 - Scheme Procedure: remove-hook! hook proc
     Remove the procedure PROC from the hook HOOK.  The return value of
     this procedure is not specified.

   reset-hook!

 - Scheme Procedure: reset-hook! hook
     Remove all procedures from the hook HOOK.  The return value of
     this procedure is not specified.

   run-hook

 - Scheme Procedure: run-hook hook . args
     Apply all procedures from the hook HOOK to the arguments ARGS.
     The order of the procedure application is first to last.  The
     return value of this procedure is not specified.

   hook->list

 - Scheme Procedure: hook->list hook
     Convert the procedure list of HOOK to a list.

   ftell

 - Scheme Procedure: ftell fd_port
     Return an integer representing the current position of FD/PORT,
     measured from the beginning.  Equivalent to:

          (seek port 0 SEEK_CUR)

   redirect-port

 - Scheme Procedure: redirect-port old new
     This procedure takes two ports and duplicates the underlying file
     descriptor from OLD-PORT into NEW-PORT.  The current file
     descriptor in NEW-PORT will be closed.  After the redirection the
     two ports will share a file position and file status flags.

     The return value is unspecified.

     Unexpected behaviour can result if both ports are subsequently used
     and the original and/or duplicate ports are buffered.

     This procedure does not have any side effects on other ports or
     revealed counts.

   dup->fdes

 - Scheme Procedure: dup->fdes fd_or_port [fd]
     Return a new integer file descriptor referring to the open file
     designated by FD_OR_PORT, which must be either an open file port
     or a file descriptor.

   dup2

 - Scheme Procedure: dup2 oldfd newfd
     A simple wrapper for the `dup2' system call.  Copies the file
     descriptor OLDFD to descriptor number NEWFD, replacing the
     previous meaning of NEWFD.  Both OLDFD and NEWFD must be integers.
     Unlike for dup->fdes or primitive-move->fdes, no attempt is made
     to move away ports which are using NEWFD.  The return value is
     unspecified.

   fileno

 - Scheme Procedure: fileno port
     Return the integer file descriptor underlying PORT.  Does not
     change its revealed count.

   isatty?

 - Scheme Procedure: isatty? port
     Return `#t' if PORT is using a serial non-file device, otherwise
     `#f'.

   fdopen

 - Scheme Procedure: fdopen fdes modes
     Return a new port based on the file descriptor FDES.  Modes are
     given by the string MODES.  The revealed count of the port is
     initialized to zero.  The modes string is the same as that
     accepted by *Note open-file: File Ports.

   primitive-move->fdes

 - Scheme Procedure: primitive-move->fdes port fd
     Moves the underlying file descriptor for PORT to the integer value
     FDES without changing the revealed count of PORT.  Any other ports
     already using this descriptor will be automatically shifted to new
     descriptors and their revealed counts reset to zero.  The return
     value is `#f' if the file descriptor already had the required
     value or `#t' if it was moved.

   fdes->ports

 - Scheme Procedure: fdes->ports fd
     Return a list of existing ports which have FDES as an underlying
     file descriptor, without changing their revealed counts.

   make-keyword-from-dash-symbol

 - Scheme Procedure: make-keyword-from-dash-symbol symbol
     Make a keyword object from a SYMBOL that starts with a dash.

   keyword?

 - Scheme Procedure: keyword? obj
     Return `#t' if the argument OBJ is a keyword, else `#f'.

   keyword-dash-symbol

 - Scheme Procedure: keyword-dash-symbol keyword
     Return the dash symbol for KEYWORD.  This is the inverse of
     `make-keyword-from-dash-symbol'.

   nil-cons

 - Scheme Procedure: nil-cons x y
     Create a new cons cell with X as the car and Y as the cdr, but
     convert Y to Scheme's end-of-list if it is a LISP nil.

   nil-car

 - Scheme Procedure: nil-car x
     Return the car of X, but convert it to LISP nil if it is Scheme's
     end-of-list.

   nil-cdr

 - Scheme Procedure: nil-cdr x
     Return the cdr of X, but convert it to LISP nil if it is Scheme's
     end-of-list.

   null

 - Scheme Procedure: null x
     Return LISP's `t' if X is nil in the LISP sense, return LISP's nil
     otherwise.

   nil-eq

 - Scheme Procedure: nil-eq x y
     Compare X and Y and return LISP's t if they are `eq?', return
     LISP's nil otherwise.

   list

 - Scheme Procedure: list . objs
     Return a list containing OBJS, the arguments to `list'.

   list*

 - Scheme Procedure: list*
     implemented by the C function "scm_cons_star"

   cons*

 - Scheme Procedure: cons* arg . rest
     Like `list', but the last arg provides the tail of the constructed
     list, returning `(cons ARG1 (cons ARG2 (cons ... ARGN)))'.
     Requires at least one argument.  If given one argument, that
     argument is returned as result.  This function is called `list*'
     in some other Schemes and in Common LISP.

   null?

 - Scheme Procedure: null? x
     Return `#t' iff X is the empty list, else `#f'.

   list?

 - Scheme Procedure: list? x
     Return `#t' iff X is a proper list, else `#f'.

   length

 - Scheme Procedure: length lst
     Return the number of elements in list LST.

   append

 - Scheme Procedure: append . args
     Return a list consisting of the elements the lists passed as
     arguments.
          (append '(x) '(y))          =>  (x y)
          (append '(a) '(b c d))      =>  (a b c d)
          (append '(a (b)) '((c)))    =>  (a (b) (c))
     The resulting list is always newly allocated, except that it
     shares structure with the last list argument.  The last argument
     may actually be any object; an improper list results if the last
     argument is not a proper list.
          (append '(a b) '(c . d))    =>  (a b c . d)
          (append '() 'a)             =>  a

   append!

 - Scheme Procedure: append! . lists
     A destructive version of `append' (*note Pairs and Lists:
     (r5rs)Pairs and Lists.).  The cdr field of each list's final pair
     is changed to point to the head of the next list, so no consing is
     performed.  Return a pointer to the mutated list.

   last-pair

 - Scheme Procedure: last-pair lst
     Return a pointer to the last pair in LST, signalling an error if
     LST is circular.

   reverse

 - Scheme Procedure: reverse lst
     Return a new list that contains the elements of LST but in reverse
     order.

   reverse!

 - Scheme Procedure: reverse! lst [new_tail]
     A destructive version of `reverse' (*note Pairs and Lists:
     (r5rs)Pairs and Lists.).  The cdr of each cell in LST is modified
     to point to the previous list element.  Return a pointer to the
     head of the reversed list.

     Caveat: because the list is modified in place, the tail of the
     original list now becomes its head, and the head of the original
     list now becomes the tail.  Therefore, the LST symbol to which the
     head of the original list was bound now points to the tail.  To
     ensure that the head of the modified list is not lost, it is wise
     to save the return value of `reverse!'

   list-ref

 - Scheme Procedure: list-ref list k
     Return the Kth element from LIST.

   list-set!

 - Scheme Procedure: list-set! list k val
     Set the Kth element of LIST to VAL.

   list-cdr-ref

 - Scheme Procedure: list-cdr-ref
     implemented by the C function "scm_list_tail"

   list-tail

 - Scheme Procedure: list-tail lst k
 - Scheme Procedure: list-cdr-ref lst k
     Return the "tail" of LST beginning with its Kth element.  The
     first element of the list is considered to be element 0.

     `list-tail' and `list-cdr-ref' are identical.  It may help to
     think of `list-cdr-ref' as accessing the Kth cdr of the list, or
     returning the results of cdring K times down LST.

   list-cdr-set!

 - Scheme Procedure: list-cdr-set! list k val
     Set the Kth cdr of LIST to VAL.

   list-head

 - Scheme Procedure: list-head lst k
     Copy the first K elements from LST into a new list, and return it.

   list-copy

 - Scheme Procedure: list-copy lst
     Return a (newly-created) copy of LST.

   sloppy-memq

 - Scheme Procedure: sloppy-memq x lst
     This procedure behaves like `memq', but does no type or error
     checking.  Its use is recommended only in writing Guile internals,
     not for high-level Scheme programs.

   sloppy-memv

 - Scheme Procedure: sloppy-memv x lst
     This procedure behaves like `memv', but does no type or error
     checking.  Its use is recommended only in writing Guile internals,
     not for high-level Scheme programs.

   sloppy-member

 - Scheme Procedure: sloppy-member x lst
     This procedure behaves like `member', but does no type or error
     checking.  Its use is recommended only in writing Guile internals,
     not for high-level Scheme programs.

   memq

 - Scheme Procedure: memq x lst
     Return the first sublist of LST whose car is `eq?' to X where the
     sublists of LST are the non-empty lists returned by `(list-tail
     LST K)' for K less than the length of LST.  If X does not occur in
     LST, then `#f' (not the empty list) is returned.

   memv

 - Scheme Procedure: memv x lst
     Return the first sublist of LST whose car is `eqv?' to X where the
     sublists of LST are the non-empty lists returned by `(list-tail
     LST K)' for K less than the length of LST.  If X does not occur in
     LST, then `#f' (not the empty list) is returned.

   member

 - Scheme Procedure: member x lst
     Return the first sublist of LST whose car is `equal?' to X where
     the sublists of LST are the non-empty lists returned by
     `(list-tail LST K)' for K less than the length of LST.  If X does
     not occur in LST, then `#f' (not the empty list) is returned.

   delq!

 - Scheme Procedure: delq! item lst
 - Scheme Procedure: delv! item lst
 - Scheme Procedure: delete! item lst
     These procedures are destructive versions of `delq', `delv' and
     `delete': they modify the pointers in the existing LST rather than
     creating a new list.  Caveat evaluator: Like other destructive
     list functions, these functions cannot modify the binding of LST,
     and so cannot be used to delete the first element of LST
     destructively.

   delv!

 - Scheme Procedure: delv! item lst
     Destructively remove all elements from LST that are `eqv?' to ITEM.

   delete!

 - Scheme Procedure: delete! item lst
     Destructively remove all elements from LST that are `equal?' to
     ITEM.

   delq

 - Scheme Procedure: delq item lst
     Return a newly-created copy of LST with elements `eq?' to ITEM
     removed.  This procedure mirrors `memq': `delq' compares elements
     of LST against ITEM with `eq?'.

   delv

 - Scheme Procedure: delv item lst
     Return a newly-created copy of LST with elements `eqv?'  to ITEM
     removed.  This procedure mirrors `memv': `delv' compares elements
     of LST against ITEM with `eqv?'.

   delete

 - Scheme Procedure: delete item lst
     Return a newly-created copy of LST with elements `equal?'  to ITEM
     removed.  This procedure mirrors `member': `delete' compares
     elements of LST against ITEM with `equal?'.

   delq1!

 - Scheme Procedure: delq1! item lst
     Like `delq!', but only deletes the first occurrence of ITEM from
     LST.  Tests for equality using `eq?'.  See also `delv1!' and
     `delete1!'.

   delv1!

 - Scheme Procedure: delv1! item lst
     Like `delv!', but only deletes the first occurrence of ITEM from
     LST.  Tests for equality using `eqv?'.  See also `delq1!' and
     `delete1!'.

   delete1!

 - Scheme Procedure: delete1! item lst
     Like `delete!', but only deletes the first occurrence of ITEM from
     LST.  Tests for equality using `equal?'.  See also `delq1!' and
     `delv1!'.

   primitive-load

 - Scheme Procedure: primitive-load filename
     Load the file named FILENAME and evaluate its contents in the
     top-level environment. The load paths are not searched; FILENAME
     must either be a full pathname or be a pathname relative to the
     current directory.  If the  variable `%load-hook' is defined, it
     should be bound to a procedure that will be called before any code
     is loaded.  See the documentation for `%load-hook' later in this
     section.

   %package-data-dir

 - Scheme Procedure: %package-data-dir
     Return the name of the directory where Scheme packages, modules and
     libraries are kept.  On most Unix systems, this will be
     `/usr/local/share/guile'.

   %library-dir

 - Scheme Procedure: %library-dir
     Return the directory where the Guile Scheme library files are
     installed.  E.g., may return "/usr/share/guile/1.3.5".

   %site-dir

 - Scheme Procedure: %site-dir
     Return the directory where the Guile site files are installed.
     E.g., may return "/usr/share/guile/site".

   parse-path

 - Scheme Procedure: parse-path path [tail]
     Parse PATH, which is expected to be a colon-separated string, into
     a list and return the resulting list with TAIL appended. If PATH
     is `#f', TAIL is returned.

   search-path

 - Scheme Procedure: search-path path filename [extensions]
     Search PATH for a directory containing a file named FILENAME. The
     file must be readable, and not a directory.  If we find one,
     return its full filename; otherwise, return `#f'.  If FILENAME is
     absolute, return it unchanged.  If given, EXTENSIONS is a list of
     strings; for each directory in PATH, we search for FILENAME
     concatenated with each EXTENSION.

   %search-load-path

 - Scheme Procedure: %search-load-path filename
     Search %LOAD-PATH for the file named FILENAME, which must be
     readable by the current user.  If FILENAME is found in the list of
     paths to search or is an absolute pathname, return its full
     pathname.  Otherwise, return `#f'.  Filenames may have any of the
     optional extensions in the `%load-extensions' list;
     `%search-load-path' will try each extension automatically.

   primitive-load-path

 - Scheme Procedure: primitive-load-path filename
     Search %LOAD-PATH for the file named FILENAME and load it into the
     top-level environment.  If FILENAME is a relative pathname and is
     not found in the list of search paths, an error is signalled.

   read-and-eval!

 - Scheme Procedure: read-and-eval! [port]
     Read a form from PORT (standard input by default), and evaluate it
     (memoizing it in the process) in the top-level environment.  If no
     data is left to be read from PORT, an `end-of-file' error is
     signalled.

   procedure->syntax

 - Scheme Procedure: procedure->syntax code
     Return a "macro" which, when a symbol defined to this value
     appears as the first symbol in an expression, returns the result
     of applying CODE to the expression and the environment.

   procedure->macro

 - Scheme Procedure: procedure->macro code
     Return a "macro" which, when a symbol defined to this value
     appears as the first symbol in an expression, evaluates the result
     of applying CODE to the expression and the environment.  For
     example:

          (define trace
            (procedure->macro
             (lambda (x env) `(set! ,(cadr x) (tracef ,(cadr x) ',(cadr x))))))
          
          (trace foo) == (set! foo (tracef foo 'foo)).

   procedure->memoizing-macro

 - Scheme Procedure: procedure->memoizing-macro code
     Return a "macro" which, when a symbol defined to this value
     appears as the first symbol in an expression, evaluates the result
     of applying CODE to the expression and the environment.

     `procedure->memoizing-macro' is the same as `procedure->macro',
     except that the expression returned by CODE replaces the original
     macro expression in the memoized form of the containing code.

   macro?

 - Scheme Procedure: macro? obj
     Return `#t' if OBJ is a regular macro, a memoizing macro or a
     syntax transformer.

   macro-type

 - Scheme Procedure: macro-type m
     Return one of the symbols `syntax', `macro' or `macro!', depending
     on whether M is a syntax transformer, a regular macro, or a
     memoizing macro, respectively.  If M is not a macro, `#f' is
     returned.

   macro-name

 - Scheme Procedure: macro-name m
     Return the name of the macro M.

   macro-transformer

 - Scheme Procedure: macro-transformer m
     Return the transformer of the macro M.

   current-module

 - Scheme Procedure: current-module
     Return the current module.

   set-current-module

 - Scheme Procedure: set-current-module module
     Set the current module to MODULE and return the previous current
     module.

   interaction-environment

 - Scheme Procedure: interaction-environment
     Return a specifier for the environment that contains
     implementation-defined bindings, typically a superset of those
     listed in the report.  The intent is that this procedure will
     return the environment in which the implementation would evaluate
     expressions dynamically typed by the user.

   env-module

 - Scheme Procedure: env-module env
     Return the module of ENV, a lexical environment.

   standard-eval-closure

 - Scheme Procedure: standard-eval-closure module
     Return an eval closure for the module MODULE.

   standard-interface-eval-closure

 - Scheme Procedure: standard-interface-eval-closure module
     Return a interface eval closure for the module MODULE. Such a
     closure does not allow new bindings to be added.

   %get-pre-modules-obarray

 - Scheme Procedure: %get-pre-modules-obarray
     Return the obarray that is used for all new bindings before the
     module system is booted.  The first call to `set-current-module'
     will boot the module system.

   exact?

 - Scheme Procedure: exact? x
     Return `#t' if X is an exact number, `#f' otherwise.

   odd?

 - Scheme Procedure: odd? n
     Return `#t' if N is an odd number, `#f' otherwise.

   even?

 - Scheme Procedure: even? n
     Return `#t' if N is an even number, `#f' otherwise.

   logand

 - Scheme Procedure: logand n1 n2
     Return the bitwise AND of the integer arguments.

          (logand) => -1
          (logand 7) => 7
          (logand #b111 #b011 #b001) => 1

   logior

 - Scheme Procedure: logior n1 n2
     Return the bitwise OR of the integer arguments.

          (logior) => 0
          (logior 7) => 7
          (logior #b000 #b001 #b011) => 3

   logxor

 - Scheme Procedure: logxor n1 n2
     Return the bitwise XOR of the integer arguments.  A bit is set in
     the result if it is set in an odd number of arguments.
          (logxor) => 0
          (logxor 7) => 7
          (logxor #b000 #b001 #b011) => 2
          (logxor #b000 #b001 #b011 #b011) => 1

   logtest

 - Scheme Procedure: logtest j k
          (logtest j k) == (not (zero? (logand j k)))
          
          (logtest #b0100 #b1011) => #f
          (logtest #b0100 #b0111) => #t

   logbit?

 - Scheme Procedure: logbit? index j
          (logbit? index j) == (logtest (integer-expt 2 index) j)
          
          (logbit? 0 #b1101) => #t
          (logbit? 1 #b1101) => #f
          (logbit? 2 #b1101) => #t
          (logbit? 3 #b1101) => #t
          (logbit? 4 #b1101) => #f

   lognot

 - Scheme Procedure: lognot n
     Return the integer which is the 2s-complement of the integer
     argument.

          (number->string (lognot #b10000000) 2)
             => "-10000001"
          (number->string (lognot #b0) 2)
             => "-1"

   integer-expt

 - Scheme Procedure: integer-expt n k
     Return N raised to the non-negative integer exponent K.

          (integer-expt 2 5)
             => 32
          (integer-expt -3 3)
             => -27

   ash

 - Scheme Procedure: ash n cnt
     The function ash performs an arithmetic shift left by CNT bits (or
     shift right, if CNT is negative).  'Arithmetic' means, that the
     function does not guarantee to keep the bit structure of N, but
     rather guarantees that the result will always be rounded towards
     minus infinity.  Therefore, the results of ash and a corresponding
     bitwise shift will differ if N is negative.

     Formally, the function returns an integer equivalent to
     `(inexact->exact (floor (* N (expt 2 CNT))))'.

          (number->string (ash #b1 3) 2)     => "1000"
          (number->string (ash #b1010 -1) 2) => "101"

   bit-extract

 - Scheme Procedure: bit-extract n start end
     Return the integer composed of the START (inclusive) through END
     (exclusive) bits of N.  The STARTth bit becomes the 0-th bit in
     the result.

          (number->string (bit-extract #b1101101010 0 4) 2)
             => "1010"
          (number->string (bit-extract #b1101101010 4 9) 2)
             => "10110"

   logcount

 - Scheme Procedure: logcount n
     Return the number of bits in integer N.  If integer is positive,
     the 1-bits in its binary representation are counted.  If negative,
     the 0-bits in its two's-complement binary representation are
     counted.  If 0, 0 is returned.

          (logcount #b10101010)
             => 4
          (logcount 0)
             => 0
          (logcount -2)
             => 1

   integer-length

 - Scheme Procedure: integer-length n
     Return the number of bits necessary to represent N.

          (integer-length #b10101010)
             => 8
          (integer-length 0)
             => 0
          (integer-length #b1111)
             => 4

   number->string

 - Scheme Procedure: number->string n [radix]
     Return a string holding the external representation of the number
     N in the given RADIX.  If N is inexact, a radix of 10 will be used.

   string->number

 - Scheme Procedure: string->number string [radix]
     Return a number of the maximally precise representation expressed
     by the given STRING. RADIX must be an exact integer, either 2, 8,
     10, or 16. If supplied, RADIX is a default radix that may be
     overridden by an explicit radix prefix in STRING (e.g. "#o177").
     If RADIX is not supplied, then the default radix is 10. If string
     is not a syntactically valid notation for a number, then
     `string->number' returns `#f'.

   number?

 - Scheme Procedure: number?
     implemented by the C function "scm_number_p"

   complex?

 - Scheme Procedure: complex? x
     Return `#t' if X is a complex number, `#f' otherwise.  Note that
     the sets of real, rational and integer values form subsets of the
     set of complex numbers, i. e. the predicate will also be fulfilled
     if X is a real, rational or integer number.

   real?

 - Scheme Procedure: real?
     implemented by the C function "scm_real_p"

   rational?

 - Scheme Procedure: rational? x
     Return `#t' if X is a rational number, `#f' otherwise.  Note that
     the set of integer values forms a subset of the set of rational
     numbers, i. e. the predicate will also be fulfilled if X is an
     integer number.  Real numbers will also satisfy this predicate,
     because of their limited precision.

   integer?

 - Scheme Procedure: integer? x
     Return `#t' if X is an integer number, `#f' else.

   inexact?

 - Scheme Procedure: inexact? x
     Return `#t' if X is an inexact number, `#f' else.

   $expt

 - Scheme Procedure: $expt x y
     Return X raised to the power of Y. This procedure does not accept
     complex arguments.

   $atan2

 - Scheme Procedure: $atan2 x y
     Return the arc tangent of the two arguments X and Y. This is
     similar to calculating the arc tangent of X / Y, except that the
     signs of both arguments are used to determine the quadrant of the
     result. This procedure does not accept complex arguments.

   make-rectangular

 - Scheme Procedure: make-rectangular real imaginary
     Return a complex number constructed of the given REAL and
     IMAGINARY parts.

   make-polar

 - Scheme Procedure: make-polar x y
     Return the complex number X * e^(i * Y).

   inexact->exact

 - Scheme Procedure: inexact->exact z
     Return an exact number that is numerically closest to Z.

   class-of

 - Scheme Procedure: class-of x
     Return the class of X.

   entity?

 - Scheme Procedure: entity? obj
     Return `#t' if OBJ is an entity.

   operator?

 - Scheme Procedure: operator? obj
     Return `#t' if OBJ is an operator.

   valid-object-procedure?

 - Scheme Procedure: valid-object-procedure? proc
     Return `#t' iff PROC is a procedure that can be used with
     `set-object-procedure'.  It is always valid to use a closure
     constructed by `lambda'.

   set-object-procedure!

 - Scheme Procedure: set-object-procedure! obj proc
     Set the object procedure of OBJ to PROC.  OBJ must be either an
     entity or an operator.

   make-class-object

 - Scheme Procedure: make-class-object metaclass layout
     Create a new class object of class METACLASS, with the slot layout
     specified by LAYOUT.

   make-subclass-object

 - Scheme Procedure: make-subclass-object class layout
     Create a subclass object of CLASS, with the slot layout specified
     by LAYOUT.

   object-properties

 - Scheme Procedure: object-properties obj
     Return OBJ's property list.

   set-object-properties!

 - Scheme Procedure: set-object-properties! obj alist
     Set OBJ's property list to ALIST.

   object-property

 - Scheme Procedure: object-property obj key
     Return the property of OBJ with name KEY.

   set-object-property!

 - Scheme Procedure: set-object-property! obj key value
     In OBJ's property list, set the property named KEY to VALUE.

   cons

 - Scheme Procedure: cons x y
     Return a newly allocated pair whose car is X and whose cdr is Y.
     The pair is guaranteed to be different (in the sense of `eq?')
     from every previously existing object.

   pair?

 - Scheme Procedure: pair? x
     Return `#t' if X is a pair; otherwise return `#f'.

   set-car!

 - Scheme Procedure: set-car! pair value
     Stores VALUE in the car field of PAIR.  The value returned by
     `set-car!' is unspecified.

   set-cdr!

 - Scheme Procedure: set-cdr! pair value
     Stores VALUE in the cdr field of PAIR.  The value returned by
     `set-cdr!' is unspecified.

   char-ready?

 - Scheme Procedure: char-ready? [port]
     Return `#t' if a character is ready on input PORT and return `#f'
     otherwise.  If `char-ready?' returns `#t' then the next
     `read-char' operation on PORT is guaranteed not to hang.  If PORT
     is a file port at end of file then `char-ready?' returns `#t'.


   drain-input

 - Scheme Procedure: drain-input port
     This procedure clears a port's input buffers, similar to the way
     that force-output clears the output buffer.  The contents of the
     buffers are returned as a single string, e.g.,

          (define p (open-input-file ...))
          (drain-input p) => empty string, nothing buffered yet.
          (unread-char (read-char p) p)
          (drain-input p) => initial chars from p, up to the buffer size.

     Draining the buffers may be useful for cleanly finishing buffered
     I/O so that the file descriptor can be used directly for further
     input.

   current-input-port

 - Scheme Procedure: current-input-port
     Return the current input port.  This is the default port used by
     many input procedures.  Initially, `current-input-port' returns
     the "standard input" in Unix and C terminology.

   current-output-port

 - Scheme Procedure: current-output-port
     Return the current output port.  This is the default port used by
     many output procedures.  Initially, `current-output-port' returns
     the "standard output" in Unix and C terminology.

   current-error-port

 - Scheme Procedure: current-error-port
     Return the port to which errors and warnings should be sent (the
     "standard error" in Unix and C terminology).

   current-load-port

 - Scheme Procedure: current-load-port
     Return the current-load-port.  The load port is used internally by
     `primitive-load'.

   set-current-input-port

 - Scheme Procedure: set-current-input-port port
 - Scheme Procedure: set-current-output-port port
 - Scheme Procedure: set-current-error-port port
     Change the ports returned by `current-input-port',
     `current-output-port' and `current-error-port', respectively, so
     that they use the supplied PORT for input or output.

   set-current-output-port

 - Scheme Procedure: set-current-output-port port
     Set the current default output port to PORT.

   set-current-error-port

 - Scheme Procedure: set-current-error-port port
     Set the current default error port to PORT.

   port-revealed

 - Scheme Procedure: port-revealed port
     Return the revealed count for PORT.

   set-port-revealed!

 - Scheme Procedure: set-port-revealed! port rcount
     Sets the revealed count for a port to a given value.  The return
     value is unspecified.

   port-mode

 - Scheme Procedure: port-mode port
     Return the port modes associated with the open port PORT.  These
     will not necessarily be identical to the modes used when the port
     was opened, since modes such as "append" which are used only
     during port creation are not retained.

   close-port

 - Scheme Procedure: close-port port
     Close the specified port object.  Return `#t' if it successfully
     closes a port or `#f' if it was already closed.  An exception may
     be raised if an error occurs, for example when flushing buffered
     output.  See also *Note close: Ports and File Descriptors, for a
     procedure which can close file descriptors.

   close-input-port

 - Scheme Procedure: close-input-port port
     Close the specified input port object.  The routine has no effect
     if the file has already been closed.  An exception may be raised
     if an error occurs.  The value returned is unspecified.

     See also *Note close: Ports and File Descriptors, for a procedure
     which can close file descriptors.

   close-output-port

 - Scheme Procedure: close-output-port port
     Close the specified output port object.  The routine has no effect
     if the file has already been closed.  An exception may be raised
     if an error occurs.  The value returned is unspecified.

     See also *Note close: Ports and File Descriptors, for a procedure
     which can close file descriptors.

   port-for-each

 - Scheme Procedure: port-for-each proc
     Apply PROC to each port in the Guile port table in turn.  The
     return value is unspecified.  More specifically, PROC is applied
     exactly once to every port that exists in the system at the time
     PORT-FOR-EACH is invoked.  Changes to the port table while
     PORT-FOR-EACH is running have no effect as far as PORT-FOR-EACH is
     concerned.

   close-all-ports-except

 - Scheme Procedure: close-all-ports-except . ports
     [DEPRECATED] Close all open file ports used by the interpreter
     except for those supplied as arguments.  This procedure was
     intended to be used before an exec call to close file descriptors
     which are not needed in the new process.  However it has the
     undesirable side effect of flushing buffers, so it's deprecated.
     Use port-for-each instead.

   input-port?

 - Scheme Procedure: input-port? x
     Return `#t' if X is an input port, otherwise return `#f'.  Any
     object satisfying this predicate also satisfies `port?'.

   output-port?

 - Scheme Procedure: output-port? x
     Return `#t' if X is an output port, otherwise return `#f'.  Any
     object satisfying this predicate also satisfies `port?'.

   port?

 - Scheme Procedure: port? x
     Return a boolean indicating whether X is a port.  Equivalent to
     `(or (input-port? X) (output-port?  X))'.

   port-closed?

 - Scheme Procedure: port-closed? port
     Return `#t' if PORT is closed or `#f' if it is open.

   eof-object?

 - Scheme Procedure: eof-object? x
     Return `#t' if X is an end-of-file object; otherwise return `#f'.

   force-output

 - Scheme Procedure: force-output [port]
     Flush the specified output port, or the current output port if PORT
     is omitted.  The current output buffer contents are passed to the
     underlying port implementation (e.g., in the case of fports, the
     data will be written to the file and the output buffer will be
     cleared.)  It has no effect on an unbuffered port.

     The return value is unspecified.

   flush-all-ports

 - Scheme Procedure: flush-all-ports
     Equivalent to calling `force-output' on all open output ports.
     The return value is unspecified.

   read-char

 - Scheme Procedure: read-char [port]
     Return the next character available from PORT, updating PORT to
     point to the following character.  If no more characters are
     available, the end-of-file object is returned.

   peek-char

 - Scheme Procedure: peek-char [port]
     Return the next character available from PORT, _without_ updating
     PORT to point to the following character.  If no more characters
     are available, the end-of-file object is returned.

   unread-char

 - Scheme Procedure: unread-char cobj [port]
     Place CHAR in PORT so that it will be read by the next read
     operation.  If called multiple times, the unread characters will
     be read again in last-in first-out order.  If PORT is not
     supplied, the current input port is used.

   unread-string

 - Scheme Procedure: unread-string str port
     Place the string STR in PORT so that its characters will be read
     in subsequent read operations.  If called multiple times, the
     unread characters will be read again in last-in first-out order.
     If PORT is not supplied, the current-input-port is used.

   seek

 - Scheme Procedure: seek fd_port offset whence
     Sets the current position of FD/PORT to the integer OFFSET, which
     is interpreted according to the value of WHENCE.

     One of the following variables should be supplied for WHENCE:

      - Variable: SEEK_SET
          Seek from the beginning of the file.

      - Variable: SEEK_CUR
          Seek from the current position.

      - Variable: SEEK_END
          Seek from the end of the file.
     If FD/PORT is a file descriptor, the underlying system call is
     `lseek'.  PORT may be a string port.

     The value returned is the new position in the file.  This means
     that the current position of a port can be obtained using:
          (seek port 0 SEEK_CUR)

   truncate-file

 - Scheme Procedure: truncate-file object [length]
     Truncates the object referred to by OBJECT to at most LENGTH
     bytes.  OBJECT can be a string containing a file name or an
     integer file descriptor or a port.  LENGTH may be omitted if
     OBJECT is not a file name, in which case the truncation occurs at
     the current port.  position.  The return value is unspecified.

   port-line

 - Scheme Procedure: port-line port
     Return the current line number for PORT.

   set-port-line!

 - Scheme Procedure: set-port-line! port line
     Set the current line number for PORT to LINE.

   port-column

 - Scheme Procedure: port-column port
 - Scheme Procedure: port-line port
     Return the current column number or line number of PORT, using the
     current input port if none is specified.  If the number is
     unknown, the result is #f.  Otherwise, the result is a 0-origin
     integer - i.e. the first character of the first line is line 0,
     column 0.  (However, when you display a file position, for example
     in an error message, we recommend you add 1 to get 1-origin
     integers.  This is because lines and column numbers traditionally
     start with 1, and that is what non-programmers will find most
     natural.)

   set-port-column!

 - Scheme Procedure: set-port-column! port column
 - Scheme Procedure: set-port-line! port line
     Set the current column or line number of PORT, using the current
     input port if none is specified.

   port-filename

 - Scheme Procedure: port-filename port
     Return the filename associated with PORT.  This function returns
     the strings "standard input", "standard output" and "standard
     error" when called on the current input, output and error ports
     respectively.

   set-port-filename!

 - Scheme Procedure: set-port-filename! port filename
     Change the filename associated with PORT, using the current input
     port if none is specified.  Note that this does not change the
     port's source of data, but only the value that is returned by
     `port-filename' and reported in diagnostic output.

   %make-void-port

 - Scheme Procedure: %make-void-port mode
     Create and return a new void port.  A void port acts like
     `/dev/null'.  The MODE argument specifies the input/output modes
     for this port: see the documentation for `open-file' in *Note File
     Ports::.

   print-options-interface

 - Scheme Procedure: print-options-interface [setting]
     Option interface for the print options. Instead of using this
     procedure directly, use the procedures `print-enable',
     `print-disable', `print-set!' and `print-options'.

   simple-format

 - Scheme Procedure: simple-format destination message . args
     Write MESSAGE to DESTINATION, defaulting to the current output
     port.  MESSAGE can contain `~A' (was `%s') and `~S' (was `%S')
     escapes.  When printed, the escapes are replaced with
     corresponding members of ARGS: `~A' formats using `display' and
     `~S' formats using `write'.  If DESTINATION is `#t', then use the
     current output port, if DESTINATION is `#f', then return a string
     containing the formatted text. Does not add a trailing newline.

   newline

 - Scheme Procedure: newline [port]
     Send a newline to PORT.  If PORT is omitted, send to the current
     output port.

   write-char

 - Scheme Procedure: write-char chr [port]
     Send character CHR to PORT.

   port-with-print-state

 - Scheme Procedure: port-with-print-state port pstate
     Create a new port which behaves like PORT, but with an included
     print state PSTATE.

   get-print-state

 - Scheme Procedure: get-print-state port
     Return the print state of the port PORT. If PORT has no associated
     print state, `#f' is returned.

   procedure-properties

 - Scheme Procedure: procedure-properties proc
     Return OBJ's property list.

   set-procedure-properties!

 - Scheme Procedure: set-procedure-properties! proc new_val
     Set OBJ's property list to ALIST.

   procedure-property

 - Scheme Procedure: procedure-property p k
     Return the property of OBJ with name KEY.

   set-procedure-property!

 - Scheme Procedure: set-procedure-property! p k v
     In OBJ's property list, set the property named KEY to VALUE.

   procedure?

 - Scheme Procedure: procedure? obj
     Return `#t' if OBJ is a procedure.

   closure?

 - Scheme Procedure: closure? obj
     Return `#t' if OBJ is a closure.

   thunk?

 - Scheme Procedure: thunk? obj
     Return `#t' if OBJ is a thunk.

   procedure-documentation

 - Scheme Procedure: procedure-documentation proc
     Return the documentation string associated with `proc'.  By
     convention, if a procedure contains more than one expression and
     the first expression is a string constant, that string is assumed
     to contain documentation for that procedure.

   procedure-with-setter?

 - Scheme Procedure: procedure-with-setter? obj
     Return `#t' if OBJ is a procedure with an associated setter
     procedure.

   make-procedure-with-setter

 - Scheme Procedure: make-procedure-with-setter procedure setter
     Create a new procedure which behaves like PROCEDURE, but with the
     associated setter SETTER.

   procedure

 - Scheme Procedure: procedure proc
     Return the procedure of PROC, which must be either a procedure
     with setter, or an operator struct.

   primitive-make-property

 - Scheme Procedure: primitive-make-property not_found_proc
     Create a "property token" that can be used with
     `primitive-property-ref' and `primitive-property-set!'.  See
     `primitive-property-ref' for the significance of NOT_FOUND_PROC.

   primitive-property-ref

 - Scheme Procedure: primitive-property-ref prop obj
     Return the property PROP of OBJ.  When no value has yet been
     associated with PROP and OBJ, call NOT-FOUND-PROC instead (see
     `primitive-make-property') and use its return value.  That value
     is also associated with OBJ via `primitive-property-set!'.  When
     NOT-FOUND-PROC is `#f', use `#f' as the default value of PROP.

   primitive-property-set!

 - Scheme Procedure: primitive-property-set! prop obj val
     Associate CODE with PROP and OBJ.

   primitive-property-del!

 - Scheme Procedure: primitive-property-del! prop obj
     Remove any value associated with PROP and OBJ.

   random

 - Scheme Procedure: random n [state]
     Return a number in [0,N).

     Accepts a positive integer or real n and returns a number of the
     same type between zero (inclusive) and N (exclusive). The values
     returned have a uniform distribution.

     The optional argument STATE must be of the type produced by
     `seed->random-state'. It defaults to the value of the variable
     *RANDOM-STATE*. This object is used to maintain the state of the
     pseudo-random-number generator and is altered as a side effect of
     the random operation.

   copy-random-state

 - Scheme Procedure: copy-random-state [state]
     Return a copy of the random state STATE.

   seed->random-state

 - Scheme Procedure: seed->random-state seed
     Return a new random state using SEED.

   random:uniform

 - Scheme Procedure: random:uniform [state]
     Return a uniformly distributed inexact real random number in [0,1).

   random:normal

 - Scheme Procedure: random:normal [state]
     Return an inexact real in a normal distribution.  The distribution
     used has mean 0 and standard deviation 1.  For a normal
     distribution with mean m and standard deviation d use `(+ m (* d
     (random:normal)))'.

   random:solid-sphere!

 - Scheme Procedure: random:solid-sphere! v [state]
     Fills vect with inexact real random numbers the sum of whose
     squares is less than 1.0.  Thinking of vect as coordinates in
     space of dimension n = (vector-length vect), the coordinates are
     uniformly distributed within the unit n-sphere.  The sum of the
     squares of the numbers is returned.

   random:hollow-sphere!

 - Scheme Procedure: random:hollow-sphere! v [state]
     Fills vect with inexact real random numbers the sum of whose
     squares is equal to 1.0.  Thinking of vect as coordinates in space
     of dimension n = (vector-length vect), the coordinates are
     uniformly distributed over the surface of the unit n-sphere.

   random:normal-vector!

 - Scheme Procedure: random:normal-vector! v [state]
     Fills vect with inexact real random numbers that are independent
     and standard normally distributed (i.e., with mean 0 and variance
     1).

   random:exp

 - Scheme Procedure: random:exp [state]
     Return an inexact real in an exponential distribution with mean 1.
     For an exponential distribution with mean u use (* u
     (random:exp)).

   %read-delimited!

 - Scheme Procedure: %read-delimited! delims str gobble [port [start
          [end]]]
     Read characters from PORT into STR until one of the characters in
     the DELIMS string is encountered.  If GOBBLE is true, discard the
     delimiter character; otherwise, leave it in the input stream for
     the next read.  If PORT is not specified, use the value of
     `(current-input-port)'.  If START or END are specified, store data
     only into the substring of STR bounded by START and END (which
     default to the beginning and end of the string, respectively).

     Return a pair consisting of the delimiter that terminated the
     string and the number of characters read.  If reading stopped at
     the end of file, the delimiter returned is the EOF-OBJECT; if the
     string was filled without encountering a delimiter, this value is
     `#f'.

   %read-line

 - Scheme Procedure: %read-line [port]
     Read a newline-terminated line from PORT, allocating storage as
     necessary.  The newline terminator (if any) is removed from the
     string, and a pair consisting of the line and its delimiter is
     returned.  The delimiter may be either a newline or the
     EOF-OBJECT; if `%read-line' is called at the end of file, it
     returns the pair `(#<eof> . #<eof>)'.

   write-line

 - Scheme Procedure: write-line obj [port]
     Display OBJ and a newline character to PORT.  If PORT is not
     specified, `(current-output-port)' is used.  This function is
     equivalent to:
          (display obj [port])
          (newline [port])

   read-options-interface

 - Scheme Procedure: read-options-interface [setting]
     Option interface for the read options. Instead of using this
     procedure directly, use the procedures `read-enable',
     `read-disable', `read-set!' and `read-options'.

   read

 - Scheme Procedure: read [port]
     Read an s-expression from the input port PORT, or from the current
     input port if PORT is not specified.  Any whitespace before the
     next token is discarded.

   read-hash-extend

 - Scheme Procedure: read-hash-extend chr proc
     Install the procedure PROC for reading expressions starting with
     the character sequence `#' and CHR.  PROC will be called with two
     arguments:  the character CHR and the port to read further data
     from. The object returned will be the return value of `read'.

   call-with-dynamic-root

 - Scheme Procedure: call-with-dynamic-root thunk handler
     Evaluate `(thunk)' in a new dynamic context, returning its value.

     If an error occurs during evaluation, apply HANDLER to the
     arguments to the throw, just as `throw' would.  If this happens,
     HANDLER is called outside the scope of the new root - it is called
     in the same dynamic context in which `call-with-dynamic-root' was
     evaluated.

     If THUNK captures a continuation, the continuation is rooted at
     the call to THUNK.  In particular, the call to
     `call-with-dynamic-root' is not captured.  Therefore,
     `call-with-dynamic-root' always returns at most one time.

     Before calling THUNK, the dynamic-wind chain is un-wound back to
     the root and a new chain started for THUNK.  Therefore, this call
     may not do what you expect:

          ;; Almost certainly a bug:
          (with-output-to-port
           some-port
          
           (lambda ()
             (call-with-dynamic-root
              (lambda ()
                (display 'fnord)
                (newline))
              (lambda (errcode) errcode))))

     The problem is, on what port will `fnord' be displayed?  You might
     expect that because of the `with-output-to-port' that it will be
     displayed on the port bound to `some-port'.  But it probably won't
     - before evaluating the thunk, dynamic winds are unwound,
     including those created by `with-output-to-port'.  So, the
     standard output port will have been re-set to its default value
     before `display' is evaluated.

     (This function was added to Guile mostly to help calls to
     functions in C libraries that can not tolerate non-local exits or
     calls that return multiple times.  If such functions call back to
     the interpreter, it should be under a new dynamic root.)

   dynamic-root

 - Scheme Procedure: dynamic-root
     Return an object representing the current dynamic root.

     These objects are only useful for comparison using `eq?'.  They
     are currently represented as numbers, but your code should in no
     way depend on this.

   read-string!/partial

 - Scheme Procedure: read-string!/partial str [port_or_fdes [start
          [end]]]
     Read characters from a port or file descriptor into a string STR.
     A port must have an underlying file descriptor -- a so-called
     fport.  This procedure is scsh-compatible and can efficiently read
     large strings.  It will:

        * attempt to fill the entire string, unless the START and/or
          END arguments are supplied.  i.e., START defaults to 0 and
          END defaults to `(string-length str)'

        * use the current input port if PORT_OR_FDES is not supplied.

        * return fewer than the requested number of characters in some
          cases, e.g., on end of file, if interrupted by a signal, or if
          not all the characters are immediately available.

        * wait indefinitely for some input if no characters are
          currently available, unless the port is in non-blocking mode.

        * read characters from the port's input buffers if available,
          instead from the underlying file descriptor.

        * return `#f' if end-of-file is encountered before reading any
          characters, otherwise return the number of characters read.

        * return 0 if the port is in non-blocking mode and no characters
          are immediately available.

        * return 0 if the request is for 0 bytes, with no end-of-file
          check.

   write-string/partial

 - Scheme Procedure: write-string/partial str [port_or_fdes [start
          [end]]]
     Write characters from a string STR to a port or file descriptor.
     A port must have an underlying file descriptor -- a so-called
     fport.  This procedure is scsh-compatible and can efficiently
     write large strings.  It will:

        * attempt to write the entire string, unless the START and/or
          END arguments are supplied.  i.e., START defaults to 0 and
          END defaults to `(string-length str)'

        * use the current output port if PORT_OF_FDES is not supplied.

        * in the case of a buffered port, store the characters in the
          port's output buffer, if all will fit.  If they will not fit
          then any existing buffered characters will be flushed before
          attempting to write the new characters directly to the
          underlying file descriptor.  If the port is in non-blocking
          mode and buffered characters can not be flushed immediately,
          then an `EAGAIN' system-error exception will be raised (Note:
          scsh does not support the use of non-blocking buffered ports.)

        * write fewer than the requested number of characters in some
          cases, e.g., if interrupted by a signal or if not all of the
          output can be accepted immediately.

        * wait indefinitely for at least one character from STR to be
          accepted by the port, unless the port is in non-blocking mode.

        * return the number of characters accepted by the port.

        * return 0 if the port is in non-blocking mode and can not
          accept at least one character from STR immediately

        * return 0 immediately if the request size is 0 bytes.

   sigaction

 - Scheme Procedure: sigaction signum [handler [flags]]
     Install or report the signal handler for a specified signal.

     SIGNUM is the signal number, which can be specified using the value
     of variables such as `SIGINT'.

     If ACTION is omitted, `sigaction' returns a pair: the CAR is the
     current signal hander, which will be either an integer with the
     value `SIG_DFL' (default action) or `SIG_IGN' (ignore), or the
     Scheme procedure which handles the signal, or `#f' if a non-Scheme
     procedure handles the signal.  The CDR contains the current
     `sigaction' flags for the handler.

     If ACTION is provided, it is installed as the new handler for
     SIGNUM.  ACTION can be a Scheme procedure taking one argument, or
     the value of `SIG_DFL' (default action) or `SIG_IGN' (ignore), or
     `#f' to restore whatever signal handler was installed before
     `sigaction' was first used.  Flags can optionally be specified for
     the new handler (`SA_RESTART' will always be added if it's
     available and the system is using restartable system calls.)  The
     return value is a pair with information about the old handler as
     described above.

     This interface does not provide access to the "signal blocking"
     facility.  Maybe this is not needed, since the thread support may
     provide solutions to the problem of consistent access to data
     structures.

   restore-signals

 - Scheme Procedure: restore-signals
     Return all signal handlers to the values they had before any call
     to `sigaction' was made.  The return value is unspecified.

   alarm

 - Scheme Procedure: alarm i
     Set a timer to raise a `SIGALRM' signal after the specified number
     of seconds (an integer).  It's advisable to install a signal
     handler for `SIGALRM' beforehand, since the default action is to
     terminate the process.

     The return value indicates the time remaining for the previous
     alarm, if any.  The new value replaces the previous alarm.  If
     there was no previous alarm, the return value is zero.

   setitimer

 - Scheme Procedure: setitimer which_timer interval_seconds
          interval_microseconds value_seconds value_microseconds
     Set the timer specified by WHICH_TIMER according to the given
     INTERVAL_SECONDS, INTERVAL_MICROSECONDS, VALUE_SECONDS, and
     VALUE_MICROSECONDS values.

     Return information about the timer's previous setting.  Errors are
     handled as described in the guile info pages under "POSIX
     Interface Conventions".

     The timers available are: `ITIMER_REAL', `ITIMER_VIRTUAL', and
     `ITIMER_PROF'.

     The return value will be a list of two cons pairs representing the
     current state of the given timer.  The first pair is the seconds
     and microseconds of the timer `it_interval', and the second pair is
     the seconds and microseconds of the timer `it_value'.

   getitimer

 - Scheme Procedure: getitimer which_timer
     Return information about the timer specified by WHICH_TIMER Errors
     are handled as described in the guile info pages under "POSIX
     Interface Conventions".

     The timers available are: `ITIMER_REAL', `ITIMER_VIRTUAL', and
     `ITIMER_PROF'.

     The return value will be a list of two cons pairs representing the
     current state of the given timer.  The first pair is the seconds
     and microseconds of the timer `it_interval', and the second pair is
     the seconds and microseconds of the timer `it_value'.

   pause

 - Scheme Procedure: pause
     Pause the current process (thread?) until a signal arrives whose
     action is to either terminate the current process or invoke a
     handler procedure.  The return value is unspecified.

   sleep

 - Scheme Procedure: sleep i
     Wait for the given number of seconds (an integer) or until a signal
     arrives.  The return value is zero if the time elapses or the
     number of seconds remaining otherwise.

   usleep

 - Scheme Procedure: usleep i
     Sleep for I microseconds.  `usleep' is not available on all
     platforms.

   raise

 - Scheme Procedure: raise sig
     Sends a specified signal SIG to the current process, where SIG is
     as described for the kill procedure.

   system

 - Scheme Procedure: system [cmd]
     Execute CMD using the operating system's "command processor".
     Under Unix this is usually the default shell `sh'.  The value
     returned is CMD's exit status as returned by `waitpid', which can
     be interpreted using the functions above.

     If `system' is called without arguments, return a boolean
     indicating whether the command processor is available.

   getenv

 - Scheme Procedure: getenv nam
     Looks up the string NAME in the current environment.  The return
     value is `#f' unless a string of the form `NAME=VALUE' is found,
     in which case the string `VALUE' is returned.

   primitive-exit

 - Scheme Procedure: primitive-exit [status]
     Terminate the current process without unwinding the Scheme stack.
     This is would typically be useful after a fork.  The exit status
     is STATUS if supplied, otherwise zero.

   restricted-vector-sort!

 - Scheme Procedure: restricted-vector-sort! vec less startpos endpos
     Sort the vector VEC, using LESS for comparing the vector elements.
     STARTPOS and ENDPOS delimit the range of the vector which gets
     sorted.  The return value is not specified.

   sorted?

 - Scheme Procedure: sorted? items less
     Return `#t' iff ITEMS is a list or a vector such that for all 1 <=
     i <= m, the predicate LESS returns true when applied to all
     elements i - 1 and i

   merge

 - Scheme Procedure: merge alist blist less
     Merge two already sorted lists into one.  Given two lists ALIST
     and BLIST, such that `(sorted? alist less?)' and `(sorted? blist
     less?)', return a new list in which the elements of ALIST and
     BLIST have been stably interleaved so that `(sorted? (merge alist
     blist less?) less?)'.  Note:  this does _not_ accept vectors.

   merge!

 - Scheme Procedure: merge! alist blist less
     Takes two lists ALIST and BLIST such that `(sorted? alist less?)'
     and `(sorted? blist less?)' and returns a new list in which the
     elements of ALIST and BLIST have been stably interleaved so that
     `(sorted? (merge alist blist less?) less?)'.  This is the
     destructive variant of `merge' Note:  this does _not_ accept
     vectors.

   sort!

 - Scheme Procedure: sort! items less
     Sort the sequence ITEMS, which may be a list or a vector.  LESS is
     used for comparing the sequence elements.  The sorting is
     destructive, that means that the input sequence is modified to
     produce the sorted result.  This is not a stable sort.

   sort

 - Scheme Procedure: sort items less
     Sort the sequence ITEMS, which may be a list or a vector.  LESS is
     used for comparing the sequence elements.  This is not a stable
     sort.

   stable-sort!

 - Scheme Procedure: stable-sort! items less
     Sort the sequence ITEMS, which may be a list or a vector. LESS is
     used for comparing the sequence elements.  The sorting is
     destructive, that means that the input sequence is modified to
     produce the sorted result.  This is a stable sort.

   stable-sort

 - Scheme Procedure: stable-sort items less
     Sort the sequence ITEMS, which may be a list or a vector. LESS is
     used for comparing the sequence elements.  This is a stable sort.

   sort-list!

 - Scheme Procedure: sort-list! items less
     Sort the list ITEMS, using LESS for comparing the list elements.
     The sorting is destructive, that means that the input list is
     modified to produce the sorted result.  This is a stable sort.

   sort-list

 - Scheme Procedure: sort-list items less
     Sort the list ITEMS, using LESS for comparing the list elements.
     This is a stable sort.

   source-properties

 - Scheme Procedure: source-properties obj
     Return the source property association list of OBJ.

   set-source-properties!

 - Scheme Procedure: set-source-properties! obj plist
     Install the association list PLIST as the source property list for
     OBJ.

   source-property

 - Scheme Procedure: source-property obj key
     Return the source property specified by KEY from OBJ's source
     property list.

   set-source-property!

 - Scheme Procedure: set-source-property! obj key datum
     Set the source property of object OBJ, which is specified by KEY
     to DATUM.  Normally, the key will be a symbol.

   stack?

 - Scheme Procedure: stack? obj
     Return `#t' if OBJ is a calling stack.

   make-stack

 - Scheme Procedure: make-stack obj . args
     Create a new stack. If OBJ is `#t', the current evaluation stack
     is used for creating the stack frames, otherwise the frames are
     taken from OBJ (which must be either a debug object or a
     continuation).

     ARGS should be a list containing any combination of integer,
     procedure and `#t' values.

     These values specify various ways of cutting away uninteresting
     stack frames from the top and bottom of the stack that
     `make-stack' returns.  They come in pairs like this: `(INNER_CUT_1
     OUTER_CUT_1 INNER_CUT_2 OUTER_CUT_2 ...)'.

     Each INNER_CUT_N can be `#t', an integer, or a procedure.  `#t'
     means to cut away all frames up to but excluding the first user
     module frame.  An integer means to cut away exactly that number of
     frames.  A procedure means to cut away all frames up to but
     excluding the application frame whose procedure matches the
     specified one.

     Each OUTER_CUT_N can be an integer or a procedure.  An integer
     means to cut away that number of frames.  A procedure means to cut
     away frames down to but excluding the application frame whose
     procedure matches the specified one.

     If the OUTER_CUT_N of the last pair is missing, it is taken as 0.

   stack-id

 - Scheme Procedure: stack-id stack
     Return the identifier given to STACK by `start-stack'.

   stack-ref

 - Scheme Procedure: stack-ref stack index
     Return the INDEX'th frame from STACK.

   stack-length

 - Scheme Procedure: stack-length stack
     Return the length of STACK.

   frame?

 - Scheme Procedure: frame? obj
     Return `#t' if OBJ is a stack frame.

   last-stack-frame

 - Scheme Procedure: last-stack-frame obj
     Return a stack which consists of a single frame, which is the last
     stack frame for OBJ. OBJ must be either a debug object or a
     continuation.

   frame-number

 - Scheme Procedure: frame-number frame
     Return the frame number of FRAME.

   frame-source

 - Scheme Procedure: frame-source frame
     Return the source of FRAME.

   frame-procedure

 - Scheme Procedure: frame-procedure frame
     Return the procedure for FRAME, or `#f' if no procedure is
     associated with FRAME.

   frame-arguments

 - Scheme Procedure: frame-arguments frame
     Return the arguments of FRAME.

   frame-previous

 - Scheme Procedure: frame-previous frame
     Return the previous frame of FRAME, or `#f' if FRAME is the first
     frame in its stack.

   frame-next

 - Scheme Procedure: frame-next frame
     Return the next frame of FRAME, or `#f' if FRAME is the last frame
     in its stack.

   frame-real?

 - Scheme Procedure: frame-real? frame
     Return `#t' if FRAME is a real frame.

   frame-procedure?

 - Scheme Procedure: frame-procedure? frame
     Return `#t' if a procedure is associated with FRAME.

   frame-evaluating-args?

 - Scheme Procedure: frame-evaluating-args? frame
     Return `#t' if FRAME contains evaluated arguments.

   frame-overflow?

 - Scheme Procedure: frame-overflow? frame
     Return `#t' if FRAME is an overflow frame.

   get-internal-real-time

 - Scheme Procedure: get-internal-real-time
     Return the number of time units since the interpreter was started.

   times

 - Scheme Procedure: times
     Return an object with information about real and processor time.
     The following procedures accept such an object as an argument and
     return a selected component:

    `tms:clock'
          The current real time, expressed as time units relative to an
          arbitrary base.

    `tms:utime'
          The CPU time units used by the calling process.

    `tms:stime'
          The CPU time units used by the system on behalf of the calling
          process.

    `tms:cutime'
          The CPU time units used by terminated child processes of the
          calling process, whose status has been collected (e.g., using
          `waitpid').

    `tms:cstime'
          Similarly, the CPU times units used by the system on behalf of
          terminated child processes.

   get-internal-run-time

 - Scheme Procedure: get-internal-run-time
     Return the number of time units of processor time used by the
     interpreter.  Both _system_ and _user_ time are included but
     subprocesses are not.

   current-time

 - Scheme Procedure: current-time
     Return the number of seconds since 1970-01-01 00:00:00 UTC,
     excluding leap seconds.

   gettimeofday

 - Scheme Procedure: gettimeofday
     Return a pair containing the number of seconds and microseconds
     since 1970-01-01 00:00:00 UTC, excluding leap seconds.  Note:
     whether true microsecond resolution is available depends on the
     operating system.

   localtime

 - Scheme Procedure: localtime time [zone]
     Return an object representing the broken down components of TIME,
     an integer like the one returned by `current-time'.  The time zone
     for the calculation is optionally specified by ZONE (a string),
     otherwise the `TZ' environment variable or the system default is
     used.

   gmtime

 - Scheme Procedure: gmtime time
     Return an object representing the broken down components of TIME,
     an integer like the one returned by `current-time'.  The values
     are calculated for UTC.

   mktime

 - Scheme Procedure: mktime sbd_time [zone]
     BD-TIME is an object representing broken down time and `zone' is
     an optional time zone specifier (otherwise the TZ environment
     variable or the system default is used).

     Returns a pair: the car is a corresponding integer time value like
     that returned by `current-time'; the cdr is a broken down time
     object, similar to as BD-TIME but with normalized values.

   tzset

 - Scheme Procedure: tzset
     Initialize the timezone from the TZ environment variable or the
     system default.  It's not usually necessary to call this procedure
     since it's done automatically by other procedures that depend on
     the timezone.

   strftime

 - Scheme Procedure: strftime format stime
     Formats a time specification TIME using TEMPLATE.  TIME is an
     object with time components in the form returned by `localtime' or
     `gmtime'.  TEMPLATE is a string which can include formatting
     specifications introduced by a `%' character.  The formatting of
     month and day names is dependent on the current locale.  The value
     returned is the formatted string.  *Note Formatting Date and Time:
     (libc)Formatting Date and Time.)

   string?

 - Scheme Procedure: string? obj
     Return `#t' if OBJ is a string, else `#f'.

   read-only-string?

 - Scheme Procedure: read-only-string? obj
     Return `#t' if OBJ is either a string or a symbol, otherwise
     return `#f'.

   list->string

 - Scheme Procedure: list->string
     implemented by the C function "scm_string"

   string

 - Scheme Procedure: string . chrs
 - Scheme Procedure: list->string chrs
     Return a newly allocated string composed of the arguments, CHRS.

   make-string

 - Scheme Procedure: make-string k [chr]
     Return a newly allocated string of length K.  If CHR is given,
     then all elements of the string are initialized to CHR, otherwise
     the contents of the STRING are unspecified.

   string-length

 - Scheme Procedure: string-length string
     Return the number of characters in STRING.

   string-ref

 - Scheme Procedure: string-ref str k
     Return character K of STR using zero-origin indexing. K must be a
     valid index of STR.

   string-set!

 - Scheme Procedure: string-set! str k chr
     Store CHR in element K of STR and return an unspecified value. K
     must be a valid index of STR.

   substring

 - Scheme Procedure: substring str start [end]
     Return a newly allocated string formed from the characters of STR
     beginning with index START (inclusive) and ending with index END
     (exclusive).  STR must be a string, START and END must be exact
     integers satisfying:

     0 <= START <= END <= (string-length STR).

   string-append

 - Scheme Procedure: string-append . args
     Return a newly allocated string whose characters form the
     concatenation of the given strings, ARGS.

   make-shared-substring

 - Scheme Procedure: make-shared-substring str [start [end]]
     Return a shared substring of STR.  The arguments are the same as
     for the `substring' function: the shared substring returned
     includes all of the text from STR between indexes START
     (inclusive) and END (exclusive).  If END is omitted, it defaults
     to the end of STR.  The shared substring returned by
     `make-shared-substring' occupies the same storage space as STR.

   string-index

 - Scheme Procedure: string-index str chr [frm [to]]
     Return the index of the first occurrence of CHR in STR.  The
     optional integer arguments FRM and TO limit the search to a
     portion of the string.  This procedure essentially implements the
     `index' or `strchr' functions from the C library.

          (string-index "weiner" #\e)
          => 1
          
          (string-index "weiner" #\e 2)
          => 4
          
          (string-index "weiner" #\e 2 4)
          => #f

   string-rindex

 - Scheme Procedure: string-rindex str chr [frm [to]]
     Like `string-index', but search from the right of the string
     rather than from the left.  This procedure essentially implements
     the `rindex' or `strrchr' functions from the C library.

          (string-rindex "weiner" #\e)
          => 4
          
          (string-rindex "weiner" #\e 2 4)
          => #f
          
          (string-rindex "weiner" #\e 2 5)
          => 4

   substring-move-left!

 - Scheme Procedure: substring-move-left!
     implemented by the C function "scm_substring_move_x"

   substring-move-right!

 - Scheme Procedure: substring-move-right!
     implemented by the C function "scm_substring_move_x"

   substring-move!

 - Scheme Procedure: substring-move! str1 start1 end1 str2 start2
     Copy the substring of STR1 bounded by START1 and END1 into STR2
     beginning at position START2.  STR1 and STR2 can be the same
     string.

   substring-fill!

 - Scheme Procedure: substring-fill! str start end fill
     Change every character in STR between START and END to FILL.

          (define y "abcdefg")
          (substring-fill! y 1 3 #\r)
          y
          => "arrdefg"

   string-null?

 - Scheme Procedure: string-null? str
     Return `#t' if STR's length is zero, and `#f' otherwise.
          (string-null? "")  => #t
          y                    => "foo"
          (string-null? y)     => #f

   string->list

 - Scheme Procedure: string->list str
     Return a newly allocated list of the characters that make up the
     given string STR. `string->list' and `list->string' are inverses
     as far as `equal?' is concerned.

   string-copy

 - Scheme Procedure: string-copy str
     Return a newly allocated copy of the given STRING.

   string-fill!

 - Scheme Procedure: string-fill! str chr
     Store CHAR in every element of the given STRING and return an
     unspecified value.

   string-upcase!

 - Scheme Procedure: string-upcase! str
     Destructively upcase every character in STR and return STR.
          y                  => "arrdefg"
          (string-upcase! y) => "ARRDEFG"
          y                  => "ARRDEFG"

   string-upcase

 - Scheme Procedure: string-upcase str
     Return a freshly allocated string containing the characters of STR
     in upper case.

   string-downcase!

 - Scheme Procedure: string-downcase! str
     Destructively downcase every character in STR and return STR.
          y                     => "ARRDEFG"
          (string-downcase! y)  => "arrdefg"
          y                     => "arrdefg"

   string-downcase

 - Scheme Procedure: string-downcase str
     Return a freshly allocation string containing the characters in
     STR in lower case.

   string-capitalize!

 - Scheme Procedure: string-capitalize! str
     Upcase the first character of every word in STR destructively and
     return STR.

          y                      => "hello world"
          (string-capitalize! y) => "Hello World"
          y                      => "Hello World"

   string-capitalize

 - Scheme Procedure: string-capitalize str
     Return a freshly allocated string with the characters in STR,
     where the first character of every word is capitalized.

   string-split

 - Scheme Procedure: string-split str chr
     Split the string STR into the a list of the substrings delimited
     by appearances of the character CHR.  Note that an empty substring
     between separator characters will result in an empty string in the
     result list.

          (string-split "root:x:0:0:root:/root:/bin/bash" #\:)
          =>
          ("root" "x" "0" "0" "root" "/root" "/bin/bash")
          
          (string-split "::" #\:)
          =>
          ("" "" "")
          
          (string-split "" #\:)
          =>
          ("")

   string-ci->symbol

 - Scheme Procedure: string-ci->symbol str
     Return the symbol whose name is STR.  STR is converted to
     lowercase before the conversion is done, if Guile is currently
     reading symbols case-insensitively.

   string=?

 - Scheme Procedure: string=? s1 s2
     Lexicographic equality predicate; return `#t' if the two strings
     are the same length and contain the same characters in the same
     positions, otherwise return `#f'.

     The procedure `string-ci=?' treats upper and lower case letters as
     though they were the same character, but `string=?' treats upper
     and lower case as distinct characters.

   string-ci=?

 - Scheme Procedure: string-ci=? s1 s2
     Case-insensitive string equality predicate; return `#t' if the two
     strings are the same length and their component characters match
     (ignoring case) at each position; otherwise return `#f'.

   string<?

 - Scheme Procedure: string<? s1 s2
     Lexicographic ordering predicate; return `#t' if S1 is
     lexicographically less than S2.

   string<=?

 - Scheme Procedure: string<=? s1 s2
     Lexicographic ordering predicate; return `#t' if S1 is
     lexicographically less than or equal to S2.

   string>?

 - Scheme Procedure: string>? s1 s2
     Lexicographic ordering predicate; return `#t' if S1 is
     lexicographically greater than S2.

   string>=?

 - Scheme Procedure: string>=? s1 s2
     Lexicographic ordering predicate; return `#t' if S1 is
     lexicographically greater than or equal to S2.

   string-ci<?

 - Scheme Procedure: string-ci<? s1 s2
     Case insensitive lexicographic ordering predicate; return `#t' if
     S1 is lexicographically less than S2 regardless of case.

   string-ci<=?

 - Scheme Procedure: string-ci<=? s1 s2
     Case insensitive lexicographic ordering predicate; return `#t' if
     S1 is lexicographically less than or equal to S2 regardless of
     case.

   string-ci>?

 - Scheme Procedure: string-ci>? s1 s2
     Case insensitive lexicographic ordering predicate; return `#t' if
     S1 is lexicographically greater than S2 regardless of case.

   string-ci>=?

 - Scheme Procedure: string-ci>=? s1 s2
     Case insensitive lexicographic ordering predicate; return `#t' if
     S1 is lexicographically greater than or equal to S2 regardless of
     case.

   object->string

 - Scheme Procedure: object->string obj [printer]
     Return a Scheme string obtained by printing OBJ.  Printing
     function can be specified by the optional second argument PRINTER
     (default: `write').

   call-with-output-string

 - Scheme Procedure: call-with-output-string proc
     Calls the one-argument procedure PROC with a newly created output
     port.  When the function returns, the string composed of the
     characters written into the port is returned.

   call-with-input-string

 - Scheme Procedure: call-with-input-string string proc
     Calls the one-argument procedure PROC with a newly created input
     port from which STRING's contents may be read.  The value yielded
     by the PROC is returned.

   open-input-string

 - Scheme Procedure: open-input-string str
     Take a string and return an input port that delivers characters
     from the string. The port can be closed by `close-input-port',
     though its storage will be reclaimed by the garbage collector if
     it becomes inaccessible.

   open-output-string

 - Scheme Procedure: open-output-string
     Return an output port that will accumulate characters for
     retrieval by `get-output-string'. The port can be closed by the
     procedure `close-output-port', though its storage will be
     reclaimed by the garbage collector if it becomes inaccessible.

   get-output-string

 - Scheme Procedure: get-output-string port
     Given an output port created by `open-output-string', return a
     string consisting of the characters that have been output to the
     port so far.

   eval-string

 - Scheme Procedure: eval-string string
     Evaluate STRING as the text representation of a Scheme form or
     forms, and return whatever value they produce.  Evaluation takes
     place in the environment returned by the procedure
     `interaction-environment'.

   make-struct-layout

 - Scheme Procedure: make-struct-layout fields
     Return a new structure layout object.

     FIELDS must be a string made up of pairs of characters strung
     together.  The first character of each pair describes a field
     type, the second a field protection.  Allowed types are 'p' for
     GC-protected Scheme data, 'u' for unprotected binary data, and 's'
     for a field that points to the structure itself.    Allowed
     protections are 'w' for mutable fields, 'r' for read-only fields,
     and 'o' for opaque fields.  The last field protection
     specification may be capitalized to indicate that the field is a
     tail-array.

   struct?

 - Scheme Procedure: struct? x
     Return `#t' iff X is a structure object, else `#f'.

   struct-vtable?

 - Scheme Procedure: struct-vtable? x
     Return `#t' iff X is a vtable structure.

   make-struct

 - Scheme Procedure: make-struct vtable tail_array_size . init
     Create a new structure.

     TYPE must be a vtable structure (*note Vtables::).

     TAIL-ELTS must be a non-negative integer.  If the layout
     specification indicated by TYPE includes a tail-array, this is the
     number of elements allocated to that array.

     The INIT1, ... are optional arguments describing how successive
     fields of the structure should be initialized.  Only fields with
     protection 'r' or 'w' can be initialized, except for fields of
     type 's', which are automatically initialized to point to the new
     structure itself; fields with protection 'o' can not be
     initialized by Scheme programs.

     If fewer optional arguments than initializable fields are supplied,
     fields of type 'p' get default value #f while fields of type 'u'
     are initialized to 0.

     Structs are currently the basic representation for record-like data
     structures in Guile.  The plan is to eventually replace them with a
     new representation which will at the same time be easier to use and
     more powerful.

     For more information, see the documentation for
     `make-vtable-vtable'.

   make-vtable-vtable

 - Scheme Procedure: make-vtable-vtable user_fields tail_array_size .
          init
     Return a new, self-describing vtable structure.

     USER-FIELDS is a string describing user defined fields of the
     vtable beginning at index `vtable-offset-user' (see
     `make-struct-layout').

     TAIL-SIZE specifies the size of the tail-array (if any) of this
     vtable.

     INIT1, ... are the optional initializers for the fields of the
     vtable.

     Vtables have one initializable system field--the struct printer.
     This field comes before the user fields in the initializers passed
     to `make-vtable-vtable' and `make-struct', and thus works as a
     third optional argument to `make-vtable-vtable' and a fourth to
     `make-struct' when creating vtables:

     If the value is a procedure, it will be called instead of the
     standard printer whenever a struct described by this vtable is
     printed.  The procedure will be called with arguments STRUCT and
     PORT.

     The structure of a struct is described by a vtable, so the vtable
     is in essence the type of the struct.  The vtable is itself a
     struct with a vtable.  This could go on forever if it weren't for
     the vtable-vtables which are self-describing vtables, and thus
     terminate the chain.

     There are several potential ways of using structs, but the standard
     one is to use three kinds of structs, together building up a type
     sub-system: one vtable-vtable working as the root and one or
     several "types", each with a set of "instances".  (The
     vtable-vtable should be compared to the class <class> which is the
     class of itself.)

          (define ball-root (make-vtable-vtable "pr" 0))
          
          (define (make-ball-type ball-color)
            (make-struct ball-root 0
          	       (make-struct-layout "pw")
                         (lambda (ball port)
                           (format port "#<a ~A ball owned by ~A>"
                                   (color ball)
                                   (owner ball)))
                         ball-color))
          (define (color ball) (struct-ref (struct-vtable ball) vtable-offset-user))
          (define (owner ball) (struct-ref ball 0))
          
          (define red (make-ball-type 'red))
          (define green (make-ball-type 'green))
          
          (define (make-ball type owner) (make-struct type 0 owner))
          
          (define ball (make-ball green 'Nisse))
          ball => #<a green ball owned by Nisse>

   struct-ref

 - Scheme Procedure: struct-ref handle pos
 - Scheme Procedure: struct-set! struct n value
     Access (or modify) the Nth field of STRUCT.

     If the field is of type 'p', then it can be set to an arbitrary
     value.

     If the field is of type 'u', then it can only be set to a
     non-negative integer value small enough to fit in one machine word.

   struct-set!

 - Scheme Procedure: struct-set! handle pos val
     Set the slot of the structure HANDLE with index POS to VAL.
     Signal an error if the slot can not be written to.

   struct-vtable

 - Scheme Procedure: struct-vtable handle
     Return the vtable structure that describes the type of STRUCT.

   struct-vtable-tag

 - Scheme Procedure: struct-vtable-tag handle
     Return the vtable tag of the structure HANDLE.

   struct-vtable-name

 - Scheme Procedure: struct-vtable-name vtable
     Return the name of the vtable VTABLE.

   set-struct-vtable-name!

 - Scheme Procedure: set-struct-vtable-name! vtable name
     Set the name of the vtable VTABLE to NAME.

   symbol?

 - Scheme Procedure: symbol? obj
     Return `#t' if OBJ is a symbol, otherwise return `#f'.

   symbol->string

 - Scheme Procedure: symbol->string s
     Return the name of SYMBOL as a string.  If the symbol was part of
     an object returned as the value of a literal expression (section
     *note Literal expressions: (r5rs)Literal expressions.) or by a
     call to the `read' procedure, and its name contains alphabetic
     characters, then the string returned will contain characters in
     the implementation's preferred standard case--some implementations
     will prefer upper case, others lower case.  If the symbol was
     returned by `string->symbol', the case of characters in the string
     returned will be the same as the case in the string that was
     passed to `string->symbol'.  It is an error to apply mutation
     procedures like `string-set!' to strings returned by this
     procedure.

     The following examples assume that the implementation's standard
     case is lower case:

          (symbol->string 'flying-fish)    => "flying-fish"
          (symbol->string 'Martin)         =>  "martin"
          (symbol->string
             (string->symbol "Malvina")) => "Malvina"

   string->symbol

 - Scheme Procedure: string->symbol string
     Return the symbol whose name is STRING. This procedure can create
     symbols with names containing special characters or letters in the
     non-standard case, but it is usually a bad idea to create such
     symbols because in some implementations of Scheme they cannot be
     read as themselves.  See `symbol->string'.

     The following examples assume that the implementation's standard
     case is lower case:

          (eq? 'mISSISSIppi 'mississippi) => #t
          (string->symbol "mISSISSIppi") => the symbol with name "mISSISSIppi"
          (eq? 'bitBlt (string->symbol "bitBlt")) => #f
          (eq? 'JollyWog
            (string->symbol (symbol->string 'JollyWog))) => #t
          (string=? "K. Harper, M.D."
            (symbol->string
              (string->symbol "K. Harper, M.D."))) =>#t

   gensym

 - Scheme Procedure: gensym [prefix]
     Create a new symbol with a name constructed from a prefix and a
     counter value. The string PREFIX can be specified as an optional
     argument. Default prefix is ` g'.  The counter is increased by 1
     at each call. There is no provision for resetting the counter.

   symbol-hash

 - Scheme Procedure: symbol-hash symbol
     Return a hash value for SYMBOL.

   symbol-fref

 - Scheme Procedure: symbol-fref s
     Return the contents of SYMBOL's "function slot".

   symbol-pref

 - Scheme Procedure: symbol-pref s
     Return the "property list" currently associated with SYMBOL.

   symbol-fset!

 - Scheme Procedure: symbol-fset! s val
     Change the binding of SYMBOL's function slot.

   symbol-pset!

 - Scheme Procedure: symbol-pset! s val
     Change the binding of SYMBOL's property slot.

   catch

 - Scheme Procedure: catch key thunk handler
     Invoke THUNK in the dynamic context of HANDLER for exceptions
     matching KEY.  If thunk throws to the symbol KEY, then HANDLER is
     invoked this way:
          (handler key args ...)

     KEY is a symbol or `#t'.

     THUNK takes no arguments.  If THUNK returns normally, that is the
     return value of `catch'.

     Handler is invoked outside the scope of its own `catch'.  If
     HANDLER again throws to the same key, a new handler from further
     up the call chain is invoked.

     If the key is `#t', then a throw to _any_ symbol will match this
     call to `catch'.

   lazy-catch

 - Scheme Procedure: lazy-catch key thunk handler
     This behaves exactly like `catch', except that it does not unwind
     the stack before invoking HANDLER.  The HANDLER procedure is not
     allowed to return: it must throw to another catch, or otherwise
     exit non-locally.

   throw

 - Scheme Procedure: throw key . args
     Invoke the catch form matching KEY, passing ARGS to the HANDLER.

     KEY is a symbol.  It will match catches of the same symbol or of
     `#t'.

     If there is no handler at all, Guile prints an error and then
     exits.

   values

 - Scheme Procedure: values . args
     Delivers all of its arguments to its continuation.  Except for
     continuations created by the `call-with-values' procedure, all
     continuations take exactly one value.  The effect of passing no
     value or more than one value to continuations that were not
     created by `call-with-values' is unspecified.

   make-variable

 - Scheme Procedure: make-variable init
     Return a variable initialized to value INIT.

   make-undefined-variable

 - Scheme Procedure: make-undefined-variable
     Return a variable that is initially unbound.

   variable?

 - Scheme Procedure: variable? obj
     Return `#t' iff OBJ is a variable object, else return `#f'.

   variable-ref

 - Scheme Procedure: variable-ref var
     Dereference VAR and return its value.  VAR must be a variable
     object; see `make-variable' and `make-undefined-variable'.

   variable-set!

 - Scheme Procedure: variable-set! var val
     Set the value of the variable VAR to VAL.  VAR must be a variable
     object, VAL can be any value. Return an unspecified value.

   variable-bound?

 - Scheme Procedure: variable-bound? var
     Return `#t' iff VAR is bound to a value.  Throws an error if VAR
     is not a variable object.

   variable-set-name-hint!

 - Scheme Procedure: variable-set-name-hint! var hint
     Do not use this function.

   builtin-variable

 - Scheme Procedure: builtin-variable name
     Return the built-in variable with the name NAME.  NAME must be a
     symbol (not a string).  Then use `variable-ref' to access its
     value.

   vector?

 - Scheme Procedure: vector? obj
     Return `#t' if OBJ is a vector, otherwise return `#f'.

   list->vector

 - Scheme Procedure: list->vector
     implemented by the C function "scm_vector"

   vector

 - Scheme Procedure: vector . l
 - Scheme Procedure: list->vector l
     Return a newly allocated vector whose elements contain the given
     arguments.  Analogous to `list'.

          (vector 'a 'b 'c) => #(a b c)

   make-vector

 - Scheme Procedure: make-vector k [fill]
     Return a newly allocated vector of K elements.  If a second
     argument is given, then each element is initialized to FILL.
     Otherwise the initial contents of each element is unspecified.

   vector->list

 - Scheme Procedure: vector->list v
     Return a newly allocated list of the objects contained in the
     elements of VECTOR.

          (vector->list '#(dah dah didah)) =>  (dah dah didah)
          (list->vector '(dididit dah)) =>  #(dididit dah)

   vector-fill!

 - Scheme Procedure: vector-fill! v fill
     Store FILL in every element of VECTOR.  The value returned by
     `vector-fill!' is unspecified.

   vector-move-left!

 - Scheme Procedure: vector-move-left! vec1 start1 end1 vec2 start2
     Copy elements from VEC1, positions START1 to END1, to VEC2
     starting at position START2.  START1 and START2 are inclusive
     indices; END1 is exclusive.

     `vector-move-left!' copies elements in leftmost order.  Therefore,
     in the case where VEC1 and VEC2 refer to the same vector,
     `vector-move-left!' is usually appropriate when START1 is greater
     than START2.

   vector-move-right!

 - Scheme Procedure: vector-move-right! vec1 start1 end1 vec2 start2
     Copy elements from VEC1, positions START1 to END1, to VEC2
     starting at position START2.  START1 and START2 are inclusive
     indices; END1 is exclusive.

     `vector-move-right!' copies elements in rightmost order.
     Therefore, in the case where VEC1 and VEC2 refer to the same
     vector, `vector-move-right!' is usually appropriate when START1 is
     less than START2.

   major-version

 - Scheme Procedure: major-version
     Return a string containing Guile's major version number.  E.g.,
     the 1 in "1.6.5".

   minor-version

 - Scheme Procedure: minor-version
     Return a string containing Guile's minor version number.  E.g.,
     the 6 in "1.6.5".

   micro-version

 - Scheme Procedure: micro-version
     Return a string containing Guile's micro version number.  E.g.,
     the 5 in "1.6.5".

   version

 - Scheme Procedure: version
 - Scheme Procedure: major-version
 - Scheme Procedure: minor-version
 - Scheme Procedure: micro-version
     Return a string describing Guile's version number, or its major,
     minor or micro version number, respectively.

          (version) => "1.6.0"
          (major-version) => "1"
          (minor-version) => "6"
          (micro-version) => "0"

   make-soft-port

 - Scheme Procedure: make-soft-port pv modes
     Return a port capable of receiving or delivering characters as
     specified by the MODES string (*note open-file: File Ports.).  PV
     must be a vector of length 5.  Its components are as follows:

       0. procedure accepting one character for output

       1. procedure accepting a string for output

       2. thunk for flushing output

       3. thunk for getting one character

       4. thunk for closing port (not by garbage collection)

     For an output-only port only elements 0, 1, 2, and 4 need be
     procedures.  For an input-only port only elements 3 and 4 need be
     procedures.  Thunks 2 and 4 can instead be `#f' if there is no
     useful operation for them to perform.

     If thunk 3 returns `#f' or an `eof-object' (*note eof-object?:
     (r5rs)Input.) it indicates that the port has reached end-of-file.
     For example:

          (define stdout (current-output-port))
          (define p (make-soft-port
                     (vector
                      (lambda (c) (write c stdout))
                      (lambda (s) (display s stdout))
                      (lambda () (display "." stdout))
                      (lambda () (char-upcase (read-char)))
                      (lambda () (display "@" stdout)))
                     "rw"))
          
          (write p p) => #<input-output: soft 8081e20>

   make-weak-vector

 - Scheme Procedure: make-weak-vector size [fill]
     Return a weak vector with SIZE elements. If the optional argument
     FILL is given, all entries in the vector will be set to FILL. The
     default value for FILL is the empty list.

   list->weak-vector

 - Scheme Procedure: list->weak-vector
     implemented by the C function "scm_weak_vector"

   weak-vector

 - Scheme Procedure: weak-vector . l
 - Scheme Procedure: list->weak-vector l
     Construct a weak vector from a list: `weak-vector' uses the list
     of its arguments while `list->weak-vector' uses its only argument
     L (a list) to construct a weak vector the same way `list->vector'
     would.

   weak-vector?

 - Scheme Procedure: weak-vector? obj
     Return `#t' if OBJ is a weak vector. Note that all weak hashes are
     also weak vectors.

   make-weak-key-hash-table

 - Scheme Procedure: make-weak-key-hash-table size
 - Scheme Procedure: make-weak-value-hash-table size
 - Scheme Procedure: make-doubly-weak-hash-table size
     Return a weak hash table with SIZE buckets. As with any hash
     table, choosing a good size for the table requires some caution.

     You can modify weak hash tables in exactly the same way you would
     modify regular hash tables. (*note Hash Tables::)

   make-weak-value-hash-table

 - Scheme Procedure: make-weak-value-hash-table size
     Return a hash table with weak values with SIZE buckets.  (*note
     Hash Tables::)

   make-doubly-weak-hash-table

 - Scheme Procedure: make-doubly-weak-hash-table size
     Return a hash table with weak keys and values with SIZE buckets.
     (*note Hash Tables::)

   weak-key-hash-table?

 - Scheme Procedure: weak-key-hash-table? obj
 - Scheme Procedure: weak-value-hash-table? obj
 - Scheme Procedure: doubly-weak-hash-table? obj
     Return `#t' if OBJ is the specified weak hash table. Note that a
     doubly weak hash table is neither a weak key nor a weak value hash
     table.

   weak-value-hash-table?

 - Scheme Procedure: weak-value-hash-table? obj
     Return `#t' if OBJ is a weak value hash table.

   doubly-weak-hash-table?

 - Scheme Procedure: doubly-weak-hash-table? obj
     Return `#t' if OBJ is a doubly weak hash table.

   string->obarray-symbol

 - Scheme Procedure: string->obarray-symbol o s [softp]
     Intern a new symbol in OBARRAY, a symbol table, with name STRING.

     If OBARRAY is `#f', use the default system symbol table.  If
     OBARRAY is `#t', the symbol should not be interned in any symbol
     table; merely return the pair (SYMBOL . #<UNDEFINED>).

     The SOFT? argument determines whether new symbol table entries
     should be created when the specified symbol is not already present
     in OBARRAY.  If SOFT? is specified and is a true value, then new
     entries should not be added for symbols not already present in the
     table; instead, simply return `#f'.

   intern-symbol

 - Scheme Procedure: intern-symbol o s
     Add a new symbol to OBARRAY with name STRING, bound to an
     unspecified initial value.  The symbol table is not modified if a
     symbol with this name is already present.

   unintern-symbol

 - Scheme Procedure: unintern-symbol o s
     Remove the symbol with name STRING from OBARRAY.  This function
     returns `#t' if the symbol was present and `#f' otherwise.

   symbol-binding

 - Scheme Procedure: symbol-binding o s
     Look up in OBARRAY the symbol whose name is STRING, and return the
     value to which it is bound.  If OBARRAY is `#f', use the global
     symbol table.  If STRING is not interned in OBARRAY, an error is
     signalled.

   symbol-interned?

 - Scheme Procedure: symbol-interned? o s
     Return `#t' if OBARRAY contains a symbol with name STRING, and
     `#f' otherwise.

   symbol-bound?

 - Scheme Procedure: symbol-bound? o s
     Return `#t' if OBARRAY contains a symbol with name STRING bound to
     a defined value.  This differs from SYMBOL-INTERNED? in that the
     mere mention of a symbol usually causes it to be interned;
     `symbol-bound?' determines whether a symbol has been given any
     meaningful value.

   symbol-set!

 - Scheme Procedure: symbol-set! o s v
     Find the symbol in OBARRAY whose name is STRING, and rebind it to
     VALUE.  An error is signalled if STRING is not present in OBARRAY.

   gentemp

 - Scheme Procedure: gentemp [prefix [obarray]]
     Create a new symbol with a name unique in an obarray.  The name is
     constructed from an optional string PREFIX and a counter value.
     The default prefix is `t'.  The OBARRAY is specified as a second
     optional argument.  Default is the system obarray where all normal
     symbols are interned.  The counter is increased by 1 at each call.
     There is no provision for resetting the counter.

   array-fill!

 - Scheme Procedure: array-fill! ra fill
     Store FILL in every element of ARRAY.  The value returned is
     unspecified.

   array-copy-in-order!

 - Scheme Procedure: array-copy-in-order!
     implemented by the C function "scm_array_copy_x"

   array-copy!

 - Scheme Procedure: array-copy! src dst
 - Scheme Procedure: array-copy-in-order! src dst
     Copy every element from vector or array SOURCE to the
     corresponding element of DESTINATION.  DESTINATION must have the
     same rank as SOURCE, and be at least as large in each dimension.
     The order is unspecified.

   array-map-in-order!

 - Scheme Procedure: array-map-in-order!
     implemented by the C function "scm_array_map_x"

   array-map!

 - Scheme Procedure: array-map! ra0 proc . lra
 - Scheme Procedure: array-map-in-order! ra0 proc . lra
     ARRAY1, ... must have the same number of dimensions as ARRAY0 and
     have a range for each index which includes the range for the
     corresponding index in ARRAY0.  PROC is applied to each tuple of
     elements of ARRAY1 ... and the result is stored as the
     corresponding element in ARRAY0.  The value returned is
     unspecified.  The order of application is unspecified.

   array-for-each

 - Scheme Procedure: array-for-each proc ra0 . lra
     Apply PROC to each tuple of elements of ARRAY0 ...  in row-major
     order.  The value returned is unspecified.

   array-index-map!

 - Scheme Procedure: array-index-map! ra proc
     Apply PROC to the indices of each element of ARRAY in turn,
     storing the result in the corresponding element.  The value
     returned and the order of application are unspecified.

     One can implement ARRAY-INDEXES as
          (define (array-indexes array)
              (let ((ra (apply make-array #f (array-shape array))))
                (array-index-map! ra (lambda x x))
                ra))
     Another example:
          (define (apl:index-generator n)
              (let ((v (make-uniform-vector n 1)))
                (array-index-map! v (lambda (i) i))
                v))

   uniform-vector-length

 - Scheme Procedure: uniform-vector-length v
     Return the number of elements in UVE.

   array?

 - Scheme Procedure: array? v [prot]
     Return `#t' if the OBJ is an array, and `#f' if not.  The
     PROTOTYPE argument is used with uniform arrays and is described
     elsewhere.

   array-rank

 - Scheme Procedure: array-rank ra
     Return the number of dimensions of OBJ.  If OBJ is not an array,
     `0' is returned.

   array-dimensions

 - Scheme Procedure: array-dimensions ra
     `Array-dimensions' is similar to `array-shape' but replaces
     elements with a `0' minimum with one greater than the maximum. So:
          (array-dimensions (make-array 'foo '(-1 3) 5)) => ((-1 3) 5)

   shared-array-root

 - Scheme Procedure: shared-array-root ra
     Return the root vector of a shared array.

   shared-array-offset

 - Scheme Procedure: shared-array-offset ra
     Return the root vector index of the first element in the array.

   shared-array-increments

 - Scheme Procedure: shared-array-increments ra
     For each dimension, return the distance between elements in the
     root vector.

   dimensions->uniform-array

 - Scheme Procedure: dimensions->uniform-array dims prot [fill]
 - Scheme Procedure: make-uniform-vector length prototype [fill]
     Create and return a uniform array or vector of type corresponding
     to PROTOTYPE with dimensions DIMS or length LENGTH.  If FILL is
     supplied, it's used to fill the array, otherwise PROTOTYPE is used.

   make-shared-array

 - Scheme Procedure: make-shared-array oldra mapfunc . dims
     `make-shared-array' can be used to create shared subarrays of other
     arrays.  The MAPPER is a function that translates coordinates in
     the new array into coordinates in the old array.  A MAPPER must be
     linear, and its range must stay within the bounds of the old
     array, but it can be otherwise arbitrary.  A simple example:
          (define fred (make-array #f 8 8))
          (define freds-diagonal
            (make-shared-array fred (lambda (i) (list i i)) 8))
          (array-set! freds-diagonal 'foo 3)
          (array-ref fred 3 3) => foo
          (define freds-center
            (make-shared-array fred (lambda (i j) (list (+ 3 i) (+ 3 j))) 2 2))
          (array-ref freds-center 0 0) => foo

   transpose-array

 - Scheme Procedure: transpose-array ra . args
     Return an array sharing contents with ARRAY, but with dimensions
     arranged in a different order.  There must be one DIM argument for
     each dimension of ARRAY.  DIM0, DIM1, ... should be integers
     between 0 and the rank of the array to be returned.  Each integer
     in that range must appear at least once in the argument list.

     The values of DIM0, DIM1, ... correspond to dimensions in the
     array to be returned, their positions in the argument list to
     dimensions of ARRAY.  Several DIMs may have the same value, in
     which case the returned array will have smaller rank than ARRAY.

          (transpose-array '#2((a b) (c d)) 1 0) => #2((a c) (b d))
          (transpose-array '#2((a b) (c d)) 0 0) => #1(a d)
          (transpose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 1 0) =>
                          #2((a 4) (b 5) (c 6))

   enclose-array

 - Scheme Procedure: enclose-array ra . axes
     DIM0, DIM1 ... should be nonnegative integers less than the rank
     of ARRAY.  ENCLOSE-ARRAY returns an array resembling an array of
     shared arrays.  The dimensions of each shared array are the same
     as the DIMth dimensions of the original array, the dimensions of
     the outer array are the same as those of the original array that
     did not match a DIM.

     An enclosed array is not a general Scheme array.  Its elements may
     not be set using `array-set!'.  Two references to the same element
     of an enclosed array will be `equal?' but will not in general be
     `eq?'.  The value returned by ARRAY-PROTOTYPE when given an
     enclosed array is unspecified.

     examples:
          (enclose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1) =>
             #<enclosed-array (#1(a d) #1(b e) #1(c f)) (#1(1 4) #1(2 5) #1(3 6))>
          
          (enclose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 0) =>
             #<enclosed-array #2((a 1) (d 4)) #2((b 2) (e 5)) #2((c 3) (f 6))>

   array-in-bounds?

 - Scheme Procedure: array-in-bounds? v . args
     Return `#t' if its arguments would be acceptable to `array-ref'.

   array-ref

 - Scheme Procedure: array-ref
     implemented by the C function "scm_uniform_vector_ref"

   uniform-vector-ref

 - Scheme Procedure: uniform-vector-ref v args
 - Scheme Procedure: array-ref v . args
     Return the element at the `(index1, index2)' element in ARRAY.

   uniform-array-set1!

 - Scheme Procedure: uniform-array-set1!
     implemented by the C function "scm_array_set_x"

   array-set!

 - Scheme Procedure: array-set! v obj . args
 - Scheme Procedure: uniform-array-set1! v obj args
     Set the element at the `(index1, index2)' element in ARRAY to
     NEW-VALUE.  The value returned by array-set! is unspecified.

   array-contents

 - Scheme Procedure: array-contents ra [strict]
     If ARRAY may be "unrolled" into a one dimensional shared array
     without changing their order (last subscript changing fastest),
     then `array-contents' returns that shared array, otherwise it
     returns `#f'.  All arrays made by MAKE-ARRAY and
     MAKE-UNIFORM-ARRAY may be unrolled, some arrays made by
     MAKE-SHARED-ARRAY may not be.

     If the optional argument STRICT is provided, a shared array will
     be returned only if its elements are stored internally contiguous
     in memory.

   uniform-array-read!

 - Scheme Procedure: uniform-array-read! ra [port_or_fd [start [end]]]
 - Scheme Procedure: uniform-vector-read! uve [port-or-fdes] [start]
          [end]
     Attempt to read all elements of URA, in lexicographic order, as
     binary objects from PORT-OR-FDES.  If an end of file is
     encountered during uniform-array-read! the objects up to that
     point only are put into URA (starting at the beginning) and the
     remainder of the array is unchanged.

     The optional arguments START and END allow a specified region of a
     vector (or linearized array) to be read, leaving the remainder of
     the vector unchanged.

     `uniform-array-read!' returns the number of objects read.
     PORT-OR-FDES may be omitted, in which case it defaults to the value
     returned by `(current-input-port)'.

   uniform-array-write

 - Scheme Procedure: uniform-array-write v [port_or_fd [start [end]]]
 - Scheme Procedure: uniform-vector-write uve [port-or-fdes] [start]
          [end]
     Writes all elements of URA as binary objects to PORT-OR-FDES.

     The optional arguments START and END allow a specified region of a
     vector (or linearized array) to be written.

     The number of objects actually written is returned.  PORT-OR-FDES
     may be omitted, in which case it defaults to the value returned by
     `(current-output-port)'.

   bit-count

 - Scheme Procedure: bit-count b bitvector
     Return the number of occurrences of the boolean B in BITVECTOR.

   bit-position

 - Scheme Procedure: bit-position item v k
     Return the minimum index of an occurrence of BOOL in BV which is
     at least K.  If no BOOL occurs within the specified range `#f' is
     returned.

   bit-set*!

 - Scheme Procedure: bit-set*! v kv obj
     If uve is a bit-vector BV and uve must be of the same length.  If
     BOOL is `#t', uve is OR'ed into BV; If BOOL is `#f', the inversion
     of uve is AND'ed into BV.

     If uve is a unsigned integer vector all the elements of uve must
     be between 0 and the `length' of BV.  The bits of BV corresponding
     to the indexes in uve are set to BOOL.  The return value is
     unspecified.

   bit-count*

 - Scheme Procedure: bit-count* v kv obj
     Return
          (bit-count (bit-set*! (if bool bv (bit-invert! bv)) uve #t) #t).
     BV is not modified.

   bit-invert!

 - Scheme Procedure: bit-invert! v
     Modify BV by replacing each element with its negation.

   array->list

 - Scheme Procedure: array->list v
     Return a list consisting of all the elements, in order, of ARRAY.

   list->uniform-array

 - Scheme Procedure: list->uniform-array ndim prot lst
 - Scheme Procedure: list->uniform-vector prot lst
     Return a uniform array of the type indicated by prototype PROT
     with elements the same as those of LST.  Elements must be of the
     appropriate type, no coercions are done.

   array-prototype

 - Scheme Procedure: array-prototype ra
     Return an object that would produce an array of the same type as
     ARRAY, if used as the PROTOTYPE for `make-uniform-array'.

   chown

 - Scheme Procedure: chown object owner group
     Change the ownership and group of the file referred to by OBJECT to
     the integer values OWNER and GROUP.  OBJECT can be a string
     containing a file name or, if the platform supports fchown, a port
     or integer file descriptor which is open on the file.  The return
     value is unspecified.

     If OBJECT is a symbolic link, either the ownership of the link or
     the ownership of the referenced file will be changed depending on
     the operating system (lchown is unsupported at present).  If OWNER
     or GROUP is specified as `-1', then that ID is not changed.

   chmod

 - Scheme Procedure: chmod object mode
     Changes the permissions of the file referred to by OBJ.  OBJ can
     be a string containing a file name or a port or integer file
     descriptor which is open on a file (in which case `fchmod' is used
     as the underlying system call).  MODE specifies the new
     permissions as a decimal number, e.g., `(chmod "foo" #o755)'.  The
     return value is unspecified.

   umask

 - Scheme Procedure: umask [mode]
     If MODE is omitted, returns a decimal number representing the
     current file creation mask.  Otherwise the file creation mask is
     set to MODE and the previous value is returned.

     E.g., `(umask #o022)' sets the mask to octal 22, decimal 18.

   open-fdes

 - Scheme Procedure: open-fdes path flags [mode]
     Similar to `open' but return a file descriptor instead of a port.

   open

 - Scheme Procedure: open path flags [mode]
     Open the file named by PATH for reading and/or writing.  FLAGS is
     an integer specifying how the file should be opened.  MODE is an
     integer specifying the permission bits of the file, if it needs to
     be created, before the umask is applied.  The default is 666 (Unix
     itself has no default).

     FLAGS can be constructed by combining variables using `logior'.
     Basic flags are:

      - Variable: O_RDONLY
          Open the file read-only.

      - Variable: O_WRONLY
          Open the file write-only.

      - Variable: O_RDWR
          Open the file read/write.

      - Variable: O_APPEND
          Append to the file instead of truncating.

      - Variable: O_CREAT
          Create the file if it does not already exist.

     See the Unix documentation of the `open' system call for
     additional flags.

   close

 - Scheme Procedure: close fd_or_port
     Similar to close-port (*note close-port: Closing.), but also works
     on file descriptors.  A side effect of closing a file descriptor
     is that any ports using that file descriptor are moved to a
     different file descriptor and have their revealed counts set to
     zero.

   close-fdes

 - Scheme Procedure: close-fdes fd
     A simple wrapper for the `close' system call.  Close file
     descriptor FD, which must be an integer.  Unlike close (*note
     close: Ports and File Descriptors.), the file descriptor will be
     closed even if a port is using it.  The return value is
     unspecified.

   stat

 - Scheme Procedure: stat object
     Return an object containing various information about the file
     determined by OBJ.  OBJ can be a string containing a file name or
     a port or integer file descriptor which is open on a file (in
     which case `fstat' is used as the underlying system call).

     The object returned by `stat' can be passed as a single parameter
     to the following procedures, all of which return integers:

    `stat:dev'
          The device containing the file.

    `stat:ino'
          The file serial number, which distinguishes this file from all
          other files on the same device.

    `stat:mode'
          The mode of the file.  This includes file type information and
          the file permission bits.  See `stat:type' and `stat:perms'
          below.

    `stat:nlink'
          The number of hard links to the file.

    `stat:uid'
          The user ID of the file's owner.

    `stat:gid'
          The group ID of the file.

    `stat:rdev'
          Device ID; this entry is defined only for character or block
          special files.

    `stat:size'
          The size of a regular file in bytes.

    `stat:atime'
          The last access time for the file.

    `stat:mtime'
          The last modification time for the file.

    `stat:ctime'
          The last modification time for the attributes of the file.

    `stat:blksize'
          The optimal block size for reading or writing the file, in
          bytes.

    `stat:blocks'
          The amount of disk space that the file occupies measured in
          units of 512 byte blocks.

     In addition, the following procedures return the information from
     stat:mode in a more convenient form:

    `stat:type'
          A symbol representing the type of file.  Possible values are
          regular, directory, symlink, block-special, char-special,
          fifo, socket and unknown

    `stat:perms'
          An integer representing the access permission bits.

   link

 - Scheme Procedure: link oldpath newpath
     Creates a new name NEWPATH in the file system for the file named
     by OLDPATH.  If OLDPATH is a symbolic link, the link may or may
     not be followed depending on the system.

   rename-file

 - Scheme Procedure: rename-file oldname newname
     Renames the file specified by OLDNAME to NEWNAME.  The return
     value is unspecified.

   delete-file

 - Scheme Procedure: delete-file str
     Deletes (or "unlinks") the file specified by PATH.

   mkdir

 - Scheme Procedure: mkdir path [mode]
     Create a new directory named by PATH.  If MODE is omitted then the
     permissions of the directory file are set using the current umask.
     Otherwise they are set to the decimal value specified with MODE.
     The return value is unspecified.

   rmdir

 - Scheme Procedure: rmdir path
     Remove the existing directory named by PATH.  The directory must
     be empty for this to succeed.  The return value is unspecified.

   directory-stream?

 - Scheme Procedure: directory-stream? obj
     Return a boolean indicating whether OBJECT is a directory stream
     as returned by `opendir'.

   opendir

 - Scheme Procedure: opendir dirname
     Open the directory specified by PATH and return a directory stream.

   readdir

 - Scheme Procedure: readdir port
     Return (as a string) the next directory entry from the directory
     stream STREAM.  If there is no remaining entry to be read then the
     end of file object is returned.

   rewinddir

 - Scheme Procedure: rewinddir port
     Reset the directory port STREAM so that the next call to `readdir'
     will return the first directory entry.

   closedir

 - Scheme Procedure: closedir port
     Close the directory stream STREAM.  The return value is
     unspecified.

   chdir

 - Scheme Procedure: chdir str
     Change the current working directory to PATH.  The return value is
     unspecified.

   getcwd

 - Scheme Procedure: getcwd
     Return the name of the current working directory.

   fcntl

 - Scheme Procedure: fcntl object cmd [value]
     Apply COMMAND to the specified file descriptor or the underlying
     file descriptor of the specified port.  VALUE is an optional
     integer argument.

     Values for COMMAND are:

    `F_DUPFD'
          Duplicate a file descriptor

    `F_GETFD'
          Get flags associated with the file descriptor.

    `F_SETFD'
          Set flags associated with the file descriptor to VALUE.

    `F_GETFL'
          Get flags associated with the open file.

    `F_SETFL'
          Set flags associated with the open file to VALUE

    `F_GETOWN'
          Get the process ID of a socket's owner, for `SIGIO' signals.

    `F_SETOWN'
          Set the process that owns a socket to VALUE, for `SIGIO'
          signals.

    `FD_CLOEXEC'
          The value used to indicate the "close on exec" flag with
          `F_GETFL' or `F_SETFL'.

   fsync

 - Scheme Procedure: fsync object
     Copies any unwritten data for the specified output file descriptor
     to disk.  If PORT/FD is a port, its buffer is flushed before the
     underlying file descriptor is fsync'd.  The return value is
     unspecified.

   symlink

 - Scheme Procedure: symlink oldpath newpath
     Create a symbolic link named PATH-TO with the value (i.e.,
     pointing to) PATH-FROM.  The return value is unspecified.

   readlink

 - Scheme Procedure: readlink path
     Return the value of the symbolic link named by PATH (a string),
     i.e., the file that the link points to.

   lstat

 - Scheme Procedure: lstat str
     Similar to `stat', but does not follow symbolic links, i.e., it
     will return information about a symbolic link itself, not the file
     it points to.  PATH must be a string.

   copy-file

 - Scheme Procedure: copy-file oldfile newfile
     Copy the file specified by PATH-FROM to PATH-TO.  The return value
     is unspecified.

   dirname

 - Scheme Procedure: dirname filename
     Return the directory name component of the file name FILENAME. If
     FILENAME does not contain a directory component, `.' is returned.

   basename

 - Scheme Procedure: basename filename [suffix]
     Return the base name of the file name FILENAME. The base name is
     the file name without any directory components.  If SUFFIX is
     provided, and is equal to the end of BASENAME, it is removed also.

   pipe

 - Scheme Procedure: pipe
     Return a newly created pipe: a pair of ports which are linked
     together on the local machine.  The _car_ is the input port and
     the _cdr_ is the output port.  Data written (and flushed) to the
     output port can be read from the input port.  Pipes are commonly
     used for communication with a newly forked child process.  The
     need to flush the output port can be avoided by making it
     unbuffered using `setvbuf'.

     Writes occur atomically provided the size of the data in bytes is
     not greater than the value of `PIPE_BUF'.  Note that the output
     port is likely to block if too much data (typically equal to
     `PIPE_BUF') has been written but not yet read from the input port.

   getgroups

 - Scheme Procedure: getgroups
     Return a vector of integers representing the current supplementary
     group IDs.

   getpw

 - Scheme Procedure: getpw [user]
     Look up an entry in the user database.  OBJ can be an integer, a
     string, or omitted, giving the behaviour of getpwuid, getpwnam or
     getpwent respectively.

   setpw

 - Scheme Procedure: setpw [arg]
     If called with a true argument, initialize or reset the password
     data stream.  Otherwise, close the stream.  The `setpwent' and
     `endpwent' procedures are implemented on top of this.

   getgr

 - Scheme Procedure: getgr [name]
     Look up an entry in the group database.  OBJ can be an integer, a
     string, or omitted, giving the behaviour of getgrgid, getgrnam or
     getgrent respectively.

   setgr

 - Scheme Procedure: setgr [arg]
     If called with a true argument, initialize or reset the group data
     stream.  Otherwise, close the stream.  The `setgrent' and
     `endgrent' procedures are implemented on top of this.

   kill

 - Scheme Procedure: kill pid sig
     Sends a signal to the specified process or group of processes.

     PID specifies the processes to which the signal is sent:

    PID greater than 0
          The process whose identifier is PID.

    PID equal to 0
          All processes in the current process group.

    PID less than -1
          The process group whose identifier is -PID

    PID equal to -1
          If the process is privileged, all processes except for some
          special system processes.  Otherwise, all processes with the
          current effective user ID.

     SIG should be specified using a variable corresponding to the Unix
     symbolic name, e.g.,

      - Variable: SIGHUP
          Hang-up signal.

      - Variable: SIGINT
          Interrupt signal.

   status:exit-val

 - Scheme Procedure: status:exit-val status
     Return the exit status value, as would be set if a process ended
     normally through a call to `exit' or `_exit', if any, otherwise
     `#f'.

   status:term-sig

 - Scheme Procedure: status:term-sig status
     Return the signal number which terminated the process, if any,
     otherwise `#f'.

   status:stop-sig

 - Scheme Procedure: status:stop-sig status
     Return the signal number which stopped the process, if any,
     otherwise `#f'.

   getppid

 - Scheme Procedure: getppid
     Return an integer representing the process ID of the parent
     process.

   getuid

 - Scheme Procedure: getuid
     Return an integer representing the current real user ID.

   getgid

 - Scheme Procedure: getgid
     Return an integer representing the current real group ID.

   geteuid

 - Scheme Procedure: geteuid
     Return an integer representing the current effective user ID.  If
     the system does not support effective IDs, then the real ID is
     returned.  `(feature? 'EIDs)' reports whether the system supports
     effective IDs.

   getegid

 - Scheme Procedure: getegid
     Return an integer representing the current effective group ID.  If
     the system does not support effective IDs, then the real ID is
     returned.  `(feature? 'EIDs)' reports whether the system supports
     effective IDs.

   setuid

 - Scheme Procedure: setuid id
     Sets both the real and effective user IDs to the integer ID,
     provided the process has appropriate privileges.  The return value
     is unspecified.

   setgid

 - Scheme Procedure: setgid id
     Sets both the real and effective group IDs to the integer ID,
     provided the process has appropriate privileges.  The return value
     is unspecified.

   seteuid

 - Scheme Procedure: seteuid id
     Sets the effective user ID to the integer ID, provided the process
     has appropriate privileges.  If effective IDs are not supported,
     the real ID is set instead - `(feature? 'EIDs)' reports whether the
     system supports effective IDs.  The return value is unspecified.

   setegid

 - Scheme Procedure: setegid id
     Sets the effective group ID to the integer ID, provided the process
     has appropriate privileges.  If effective IDs are not supported,
     the real ID is set instead - `(feature? 'EIDs)' reports whether the
     system supports effective IDs.  The return value is unspecified.

   getpgrp

 - Scheme Procedure: getpgrp
     Return an integer representing the current process group ID.  This
     is the POSIX definition, not BSD.

   setpgid

 - Scheme Procedure: setpgid pid pgid
     Move the process PID into the process group PGID.  PID or PGID
     must be integers: they can be zero to indicate the ID of the
     current process.  Fails on systems that do not support job control.
     The return value is unspecified.

   setsid

 - Scheme Procedure: setsid
     Creates a new session.  The current process becomes the session
     leader and is put in a new process group.  The process will be
     detached from its controlling terminal if it has one.  The return
     value is an integer representing the new process group ID.

   ttyname

 - Scheme Procedure: ttyname port
     Return a string with the name of the serial terminal device
     underlying PORT.

   ctermid

 - Scheme Procedure: ctermid
     Return a string containing the file name of the controlling
     terminal for the current process.

   tcgetpgrp

 - Scheme Procedure: tcgetpgrp port
     Return the process group ID of the foreground process group
     associated with the terminal open on the file descriptor
     underlying PORT.

     If there is no foreground process group, the return value is a
     number greater than 1 that does not match the process group ID of
     any existing process group.  This can happen if all of the
     processes in the job that was formerly the foreground job have
     terminated, and no other job has yet been moved into the
     foreground.

   tcsetpgrp

 - Scheme Procedure: tcsetpgrp port pgid
     Set the foreground process group ID for the terminal used by the
     file descriptor underlying PORT to the integer PGID.  The calling
     process must be a member of the same session as PGID and must have
     the same controlling terminal.  The return value is unspecified.

   execl

 - Scheme Procedure: execl filename . args
     Executes the file named by PATH as a new process image.  The
     remaining arguments are supplied to the process; from a C program
     they are accessible as the `argv' argument to `main'.
     Conventionally the first ARG is the same as PATH.  All arguments
     must be strings.

     If ARG is missing, PATH is executed with a null argument list,
     which may have system-dependent side-effects.

     This procedure is currently implemented using the `execv' system
     call, but we call it `execl' because of its Scheme calling
     interface.

   execlp

 - Scheme Procedure: execlp filename . args
     Similar to `execl', however if FILENAME does not contain a slash
     then the file to execute will be located by searching the
     directories listed in the `PATH' environment variable.

     This procedure is currently implemented using the `execvp' system
     call, but we call it `execlp' because of its Scheme calling
     interface.

   execle

 - Scheme Procedure: execle filename env . args
     Similar to `execl', but the environment of the new process is
     specified by ENV, which must be a list of strings as returned by
     the `environ' procedure.

     This procedure is currently implemented using the `execve' system
     call, but we call it `execle' because of its Scheme calling
     interface.

   environ

 - Scheme Procedure: environ [env]
     If ENV is omitted, return the current environment (in the Unix
     sense) as a list of strings.  Otherwise set the current
     environment, which is also the default environment for child
     processes, to the supplied list of strings.  Each member of ENV
     should be of the form `NAME=VALUE' and values of `NAME' should not
     be duplicated.  If ENV is supplied then the return value is
     unspecified.

   tmpnam

 - Scheme Procedure: tmpnam
     Return a name in the file system that does not match any existing
     file.  However there is no guarantee that another process will not
     create the file after `tmpnam' is called.  Care should be taken if
     opening the file, e.g., use the `O_EXCL' open flag or use
     `mkstemp!' instead.

   mkstemp!

 - Scheme Procedure: mkstemp! tmpl
     Create a new unique file in the file system and returns a new
     buffered port open for reading and writing to the file.  TMPL is a
     string specifying where the file should be created: it must end
     with `XXXXXX' and will be changed in place to return the name of
     the temporary file.

   utime

 - Scheme Procedure: utime pathname [actime [modtime]]
     `utime' sets the access and modification times for the file named
     by PATH.  If ACTIME or MODTIME is not supplied, then the current
     time is used.  ACTIME and MODTIME must be integer time values as
     returned by the `current-time' procedure.
          (utime "foo" (- (current-time) 3600))
     will set the access time to one hour in the past and the
     modification time to the current time.

   access?

 - Scheme Procedure: access? path how
     Return `#t' if PATH corresponds to an existing file and the
     current process has the type of access specified by HOW, otherwise
     `#f'.  HOW should be specified using the values of the variables
     listed below.  Multiple values can be combined using a bitwise or,
     in which case `#t' will only be returned if all accesses are
     granted.

     Permissions are checked using the real id of the current process,
     not the effective id, although it's the effective id which
     determines whether the access would actually be granted.

      - Variable: R_OK
          test for read permission.

      - Variable: W_OK
          test for write permission.

      - Variable: X_OK
          test for execute permission.

      - Variable: F_OK
          test for existence of the file.

   getpid

 - Scheme Procedure: getpid
     Return an integer representing the current process ID.

   putenv

 - Scheme Procedure: putenv str
     Modifies the environment of the current process, which is also the
     default environment inherited by child processes.

     If STRING is of the form `NAME=VALUE' then it will be written
     directly into the environment, replacing any existing environment
     string with name matching `NAME'.  If STRING does not contain an
     equal sign, then any existing string with name matching STRING will
     be removed.

     The return value is unspecified.

   setlocale

 - Scheme Procedure: setlocale category [locale]
     If LOCALE is omitted, return the current value of the specified
     locale category as a system-dependent string.  CATEGORY should be
     specified using the values `LC_COLLATE', `LC_ALL' etc.

     Otherwise the specified locale category is set to the string
     LOCALE and the new value is returned as a system-dependent string.
     If LOCALE is an empty string, the locale will be set using
     environment variables.

   mknod

 - Scheme Procedure: mknod path type perms dev
     Creates a new special file, such as a file corresponding to a
     device.  PATH specifies the name of the file.  TYPE should be one
     of the following symbols: regular, directory, symlink,
     block-special, char-special, fifo, or socket.  PERMS (an integer)
     specifies the file permissions.  DEV (an integer) specifies which
     device the special file refers to.  Its exact interpretation
     depends on the kind of special file being created.

     E.g.,
          (mknod "/dev/fd0" 'block-special #o660 (+ (* 2 256) 2))

     The return value is unspecified.

   nice

 - Scheme Procedure: nice incr
     Increment the priority of the current process by INCR.  A higher
     priority value means that the process runs less often.  The return
     value is unspecified.

   sync

 - Scheme Procedure: sync
     Flush the operating system disk buffers.  The return value is
     unspecified.

   chroot

 - Scheme Procedure: chroot path
     Change the root directory to that specified in PATH.  This
     directory will be used for path names beginning with `/'.  The
     root directory is inherited by all children of the current
     process.  Only the superuser may change the root directory.

   getlogin

 - Scheme Procedure: getlogin
     Return a string containing the name of the user logged in on the
     controlling terminal of the process, or `#f' if this information
     cannot be obtained.

   cuserid

 - Scheme Procedure: cuserid
     Return a string containing a user name associated with the
     effective user id of the process.  Return `#f' if this information
     cannot be obtained.

   getpass

 - Scheme Procedure: getpass prompt
     Display PROMPT to the standard error output and read a password
     from `/dev/tty'.  If this file is not accessible, it reads from
     standard input.  The password may be up to 127 characters in
     length.  Additional characters and the terminating newline
     character are discarded.  While reading the password, echoing and
     the generation of signals by special characters is disabled.

   gethostname

 - Scheme Procedure: gethostname
     Return the host name of the current processor.

   gethost

 - Scheme Procedure: gethost [host]
 - Scheme Procedure: gethostbyname hostname
 - Scheme Procedure: gethostbyaddr address
     Look up a host by name or address, returning a host object.  The
     `gethost' procedure will accept either a string name or an integer
     address; if given no arguments, it behaves like `gethostent' (see
     below).  If a name or address is supplied but the address can not
     be found, an error will be thrown to one of the keys:
     `host-not-found', `try-again', `no-recovery' or `no-data',
     corresponding to the equivalent `h_error' values.  Unusual
     conditions may result in errors thrown to the `system-error' or
     `misc_error' keys.

   sethost

 - Scheme Procedure: sethost [stayopen]
     If STAYOPEN is omitted, this is equivalent to `endhostent'.
     Otherwise it is equivalent to `sethostent stayopen'.

   htons

 - Scheme Procedure: htons value
     Convert a 16 bit quantity from host to network byte ordering.
     VALUE is packed into 2 bytes, which are then converted and
     returned as a new integer.

   ntohs

 - Scheme Procedure: ntohs value
     Convert a 16 bit quantity from network to host byte ordering.
     VALUE is packed into 2 bytes, which are then converted and
     returned as a new integer.

   htonl

 - Scheme Procedure: htonl value
     Convert a 32 bit quantity from host to network byte ordering.
     VALUE is packed into 4 bytes, which are then converted and
     returned as a new integer.

   ntohl

 - Scheme Procedure: ntohl value
     Convert a 32 bit quantity from network to host byte ordering.
     VALUE is packed into 4 bytes, which are then converted and
     returned as a new integer.

   inet-aton

 - Scheme Procedure: inet-aton address
     Convert an IPv4 Internet address from printable string (dotted
     decimal notation) to an integer.  E.g.,

          (inet-aton "127.0.0.1") => 2130706433

   inet-ntoa

 - Scheme Procedure: inet-ntoa inetid
     Convert an IPv4 Internet address to a printable (dotted decimal
     notation) string.  E.g.,

          (inet-ntoa 2130706433) => "127.0.0.1"

   inet-netof

 - Scheme Procedure: inet-netof address
     Return the network number part of the given IPv4 Internet address.
     E.g.,

          (inet-netof 2130706433) => 127

   inet-makeaddr

 - Scheme Procedure: inet-makeaddr net lna
     Make an IPv4 Internet address by combining the network number NET
     with the local-address-within-network number LNA.  E.g.,

          (inet-makeaddr 127 1) => 2130706433

   socket

 - Scheme Procedure: socket family style proto
     Return a new socket port of the type specified by FAMILY, STYLE
     and PROTO.  All three parameters are integers.  Supported values
     for FAMILY are `AF_UNIX', `AF_INET' and `AF_INET6'.  Typical
     values for STYLE are `SOCK_STREAM', `SOCK_DGRAM' and `SOCK_RAW'.

     PROTO can be obtained from a protocol name using `getprotobyname'.
     A value of zero specifies the default protocol, which is usually
     right.

     A single socket port cannot by used for communication until it has
     been connected to another socket.

   socketpair

 - Scheme Procedure: socketpair family style proto
     Return a pair of connected (but unnamed) socket ports of the type
     specified by FAMILY, STYLE and PROTO.  Many systems support only
     socket pairs of the `AF_UNIX' family.  Zero is likely to be the
     only meaningful value for PROTO.

   getsockopt

 - Scheme Procedure: getsockopt sock level optname
     Return the value of a particular socket option for the socket port
     SOCK.  LEVEL is an integer code for type of option being
     requested, e.g., `SOL_SOCKET' for socket-level options.  OPTNAME
     is an integer code for the option required and should be specified
     using one of the symbols `SO_DEBUG', `SO_REUSEADDR' etc.

     The returned value is typically an integer but `SO_LINGER' returns
     a pair of integers.

   setsockopt

 - Scheme Procedure: setsockopt sock level optname value
     Set the value of a particular socket option for the socket port
     SOCK.  LEVEL is an integer code for type of option being set,
     e.g., `SOL_SOCKET' for socket-level options.  OPTNAME is an
     integer code for the option to set and should be specified using
     one of the symbols `SO_DEBUG', `SO_REUSEADDR' etc.  VALUE is the
     value to which the option should be set.  For most options this
     must be an integer, but for `SO_LINGER' it must be a pair.

     The return value is unspecified.

   shutdown

 - Scheme Procedure: shutdown sock how
     Sockets can be closed simply by using `close-port'. The `shutdown'
     procedure allows reception or transmission on a connection to be
     shut down individually, according to the parameter HOW:

    0
          Stop receiving data for this socket.  If further data
          arrives,  reject it.

    1
          Stop trying to transmit data from this socket.  Discard any
          data waiting to be sent.  Stop looking for acknowledgement of
          data already sent; don't retransmit it if it is lost.

    2
          Stop both reception and transmission.

     The return value is unspecified.

   connect

 - Scheme Procedure: connect sock fam address . args
     Initiate a connection from a socket using a specified address
     family to the address specified by ADDRESS and possibly ARGS.  The
     format required for ADDRESS and ARGS depends on the family of the
     socket.

     For a socket of family `AF_UNIX', only ADDRESS is specified and
     must be a string with the filename where the socket is to be
     created.

     For a socket of family `AF_INET', ADDRESS must be an integer IPv4
     host address and ARGS must be a single integer port number.

     For a socket of family `AF_INET6', ADDRESS must be an integer IPv6
     host address and ARGS may be up to three integers: port [flowinfo]
     [scope_id], where flowinfo and scope_id default to zero.

     The return value is unspecified.

   bind

 - Scheme Procedure: bind sock fam address . args
     Assign an address to the socket port SOCK.  Generally this only
     needs to be done for server sockets, so they know where to look
     for incoming connections.  A socket without an address will be
     assigned one automatically when it starts communicating.

     The format of ADDRESS and ARGS depends on the family of the socket.

     For a socket of family `AF_UNIX', only ADDRESS is specified and
     must be a string with the filename where the socket is to be
     created.

     For a socket of family `AF_INET', ADDRESS must be an integer IPv4
     address and ARGS must be a single integer port number.

     The values of the following variables can also be used for ADDRESS:

      - Variable: INADDR_ANY
          Allow connections from any address.

      - Variable: INADDR_LOOPBACK
          The address of the local host using the loopback device.

      - Variable: INADDR_BROADCAST
          The broadcast address on the local network.

      - Variable: INADDR_NONE
          No address.

     For a socket of family `AF_INET6', ADDRESS must be an integer IPv6
     address and ARGS may be up to three integers: port [flowinfo]
     [scope_id], where flowinfo and scope_id default to zero.

     The return value is unspecified.

   listen

 - Scheme Procedure: listen sock backlog
     Enable SOCK to accept connection requests.  BACKLOG is an integer
     specifying the maximum length of the queue for pending connections.
     If the queue fills, new clients will fail to connect until the
     server calls `accept' to accept a connection from the queue.

     The return value is unspecified.

   accept

 - Scheme Procedure: accept sock
     Accept a connection on a bound, listening socket.  If there are no
     pending connections in the queue, wait until one is available
     unless the non-blocking option has been set on the socket.

     The return value is a pair in which the _car_ is a new socket port
     for the connection and the _cdr_ is an object with address
     information about the client which initiated the connection.

     SOCK does not become part of the connection and will continue to
     accept new requests.

   getsockname

 - Scheme Procedure: getsockname sock
     Return the address of SOCK, in the same form as the object
     returned by `accept'.  On many systems the address of a socket in
     the `AF_FILE' namespace cannot be read.

   getpeername

 - Scheme Procedure: getpeername sock
     Return the address that SOCK is connected to, in the same form as
     the object returned by `accept'.  On many systems the address of a
     socket in the `AF_FILE' namespace cannot be read.

   recv!

 - Scheme Procedure: recv! sock buf [flags]
     Receive data from a socket port.  SOCK must already be bound to
     the address from which data is to be received.  BUF is a string
     into which the data will be written.  The size of BUF limits the
     amount of data which can be received: in the case of packet
     protocols, if a packet larger than this limit is encountered then
     some data will be irrevocably lost.

     The optional FLAGS argument is a value or bitwise OR of MSG_OOB,
     MSG_PEEK, MSG_DONTROUTE etc.

     The value returned is the number of bytes read from the socket.

     Note that the data is read directly from the socket file
     descriptor: any unread buffered port data is ignored.

   send

 - Scheme Procedure: send sock message [flags]
     Transmit the string MESSAGE on a socket port SOCK.  SOCK must
     already be bound to a destination address.  The value returned is
     the number of bytes transmitted - it's possible for this to be
     less than the length of MESSAGE if the socket is set to be
     non-blocking.  The optional FLAGS argument is a value or bitwise
     OR of MSG_OOB, MSG_PEEK, MSG_DONTROUTE etc.

     Note that the data is written directly to the socket file
     descriptor: any unflushed buffered port data is ignored.

   recvfrom!

 - Scheme Procedure: recvfrom! sock str [flags [start [end]]]
     Return data from the socket port SOCK and also information about
     where the data was received from.  SOCK must already be bound to
     the address from which data is to be received.  `str', is a string
     into which the data will be written.  The size of STR limits the
     amount of data which can be received: in the case of packet
     protocols, if a packet larger than this limit is encountered then
     some data will be irrevocably lost.

     The optional FLAGS argument is a value or bitwise OR of `MSG_OOB',
     `MSG_PEEK', `MSG_DONTROUTE' etc.

     The value returned is a pair: the _car_ is the number of bytes
     read from the socket and the _cdr_ an address object in the same
     form as returned by `accept'.  The address will given as `#f' if
     not available, as is usually the case for stream sockets.

     The START and END arguments specify a substring of STR to which
     the data should be written.

     Note that the data is read directly from the socket file
     descriptor: any unread buffered port data is ignored.

   sendto

 - Scheme Procedure: sendto sock message fam address . args_and_flags
     Transmit the string MESSAGE on the socket port SOCK.  The
     destination address is specified using the FAM, ADDRESS and
     ARGS_AND_FLAGS arguments, in a similar way to the `connect'
     procedure.  ARGS_AND_FLAGS contains the usual connection arguments
     optionally followed by a flags argument, which is a value or
     bitwise OR of MSG_OOB, MSG_PEEK, MSG_DONTROUTE etc.

     The value returned is the number of bytes transmitted - it's
     possible for this to be less than the length of MESSAGE if the
     socket is set to be non-blocking.  Note that the data is written
     directly to the socket file descriptor: any unflushed buffered
     port data is ignored.

   regexp?

 - Scheme Procedure: regexp? obj
     Return `#t' if OBJ is a compiled regular expression, or `#f'
     otherwise.

   make-regexp

 - Scheme Procedure: make-regexp pat . flags
     Compile the regular expression described by PAT, and return the
     compiled regexp structure.  If PAT does not describe a legal
     regular expression, `make-regexp' throws a
     `regular-expression-syntax' error.

     The FLAGS arguments change the behavior of the compiled regular
     expression.  The following flags may be supplied:

    `regexp/icase'
          Consider uppercase and lowercase letters to be the same when
          matching.

    `regexp/newline'
          If a newline appears in the target string, then permit the
          `^' and `$' operators to match immediately after or
          immediately before the newline, respectively.  Also, the `.'
          and `[^...]' operators will never match a newline character.
          The intent of this flag is to treat the target string as a
          buffer containing many lines of text, and the regular
          expression as a pattern that may match a single one of those
          lines.

    `regexp/basic'
          Compile a basic ("obsolete") regexp instead of the extended
          ("modern") regexps that are the default.  Basic regexps do
          not consider `|', `+' or `?' to be special characters, and
          require the `{...}' and `(...)' metacharacters to be
          backslash-escaped (*note Backslash Escapes::).  There are
          several other differences between basic and extended regular
          expressions, but these are the most significant.

    `regexp/extended'
          Compile an extended regular expression rather than a basic
          regexp.  This is the default behavior; this flag will not
          usually be needed.  If a call to `make-regexp' includes both
          `regexp/basic' and `regexp/extended' flags, the one which
          comes last will override the earlier one.

   regexp-exec

 - Scheme Procedure: regexp-exec rx str [start [flags]]
     Match the compiled regular expression RX against `str'.  If the
     optional integer START argument is provided, begin matching from
     that position in the string.  Return a match structure describing
     the results of the match, or `#f' if no match could be found.

     The FLAGS arguments change the matching behavior.  The following
     flags may be supplied:

    `regexp/notbol'
          Operator `^' always fails (unless `regexp/newline' is used).
          Use this when the beginning of the string should not be
          considered the beginning of a line.

    `regexp/noteol'
          Operator `$' always fails (unless `regexp/newline' is used).
          Use this when the end of the string should not be considered
          the end of a line.

